# 面向对象的C++学习框架


- [面向对象的C++学习框架](#面向对象的c学习框架)
  - [1.介绍与引入](#1介绍与引入)
    - [1.1关键特性](#11关键特性)
    - [1.2知识点总清单](#12知识点总清单)
  - [2.C++预备知识（C语言基础与C++新特性）](#2c预备知识c语言基础与c新特性)
    - [2.1字符集](#21字符集)
    - [2.2关键字](#22关键字)
      - [2.2.1auto自动推断变量](#221auto自动推断变量)
      - [2.2.2decltype推断变量类型](#222decltype推断变量类型)
      - [2.2.3bool布尔变量](#223bool布尔变量)
      - [2.2.4throw/try/catch异常处理](#224throwtrycatch异常处理)
      - [2.2.5class类与对象](#225class类与对象)
      - [2.2.6constexpr常量表达式](#226constexpr常量表达式)
      - [2.2.7new与delete管理对象](#227new与delete管理对象)
      - [2.2.8类型转换](#228类型转换)
      - [2.2.9explicit显式调用](#229explicit显式调用)
      - [2.2.10export全局引用](#2210export全局引用)
      - [2.2.11friend友元函数](#2211friend友元函数)
      - [2.2.12mutable可变变量](#2212mutable可变变量)
      - [2.2.13namespace命名空间](#2213namespace命名空间)
      - [2.2.14noexcept禁止异常](#2214noexcept禁止异常)
      - [2.2.15nullptr空指针](#2215nullptr空指针)
      - [2.2.16private、protected和public](#2216privateprotected和public)
      - [2.2.17typeid获取类型信息](#2217typeid获取类型信息)
      - [2.2.18operator重载操作符](#2218operator重载操作符)
      - [2.2.19template模板](#2219template模板)
      - [2.2.20this指针](#2220this指针)
      - [2.2.21thread\_local线程私有](#2221thread_local线程私有)
      - [2.2.22virtual虚函数](#2222virtual虚函数)
    - [2.3标识符](#23标识符)
    - [2.4操作符（运算符）](#24操作符运算符)
    - [2.5分隔符](#25分隔符)
    - [2.6空白符](#26空白符)
    - [2.7基本数据类型](#27基本数据类型)
    - [2.8常量](#28常量)
      - [2.8.1整型常量](#281整型常量)
      - [2.8.2实型常量](#282实型常量)
      - [2.8.3字符常量](#283字符常量)
      - [2.8.4字符串常量](#284字符串常量)
      - [2.8.5布尔常量](#285布尔常量)
    - [2.9变量](#29变量)
      - [2.9.1变量的声明和定义](#291变量的声明和定义)
      - [2.9.2变量的初始化](#292变量的初始化)
      - [2.9.3变量的存储类型](#293变量的存储类型)
    - [2.10符号常量](#210符号常量)
    - [2.11constexpr与常量表达式](#211constexpr与常量表达式)
    - [2.12运算符与表达式](#212运算符与表达式)
      - [\*操作符的分类](#操作符的分类)
      - [2.12.1算术操作符(双目)](#2121算术操作符双目)
      - [2.12.2移位操作符](#2122移位操作符)
        - [左移操作符](#左移操作符)
        - [右移操作符](#右移操作符)
      - [2.12.3位操作符](#2123位操作符)
      - [2.12.4赋值操作符](#2124赋值操作符)
      - [2.12.5单目操作符](#2125单目操作符)
      - [2.12.6关系操作符](#2126关系操作符)
      - [7.逻辑操作符](#7逻辑操作符)
        - [短路问题](#短路问题)
      - [8.条件操作符(三目操作符)](#8条件操作符三目操作符)
      - [9.逗号表达式](#9逗号表达式)
      - [10.下标访问操作符`[]`](#10下标访问操作符)
      - [11.函数调用操作符`()`](#11函数调用操作符)
      - [12.结构成员访问操作符](#12结构成员访问操作符)
        - [什么是结构体](#什么是结构体)
          - [结构的声明](#结构的声明)
          - [结构体变量的定义和初始化](#结构体变量的定义和初始化)
        - [结构成员访问操作符](#结构成员访问操作符)
          - [结构体成员的直接访问](#结构体成员的直接访问)
          - [结构体成员的间接访问](#结构体成员的间接访问)
  - [C++中的引用](#c中的引用)
    - [一、引用的概念](#一引用的概念)
    - [二、引用特性](#二引用特性)
    - [三、常引用](#三常引用)
  - [C++函数的参数传递](#c函数的参数传递)
    - [一、传值参数](#一传值参数)
    - [二、指针参数](#二指针参数)
    - [三、引用参数](#三引用参数)
    - [四、使用const引用参数](#四使用const引用参数)
  - [C++内联函数](#c内联函数)
    - [一、认识内联函数](#一认识内联函数)
    - [二、内联函数和宏定义](#二内联函数和宏定义)
    - [三、何时使用内联函数](#三何时使用内联函数)
    - [四.注意事项](#四注意事项)
    - [五.类的内联成员函数](#五类的内联成员函数)
  - [C++默认形参问题](#c默认形参问题)
    - [一、带默认形参值的函数](#一带默认形参值的函数)
    - [二、默认形参值的说明次序](#二默认形参值的说明次序)
    - [三、默认形参值的作用域](#三默认形参值的作用域)
  - [C++构造函数的各种用法全面解析](#c构造函数的各种用法全面解析)
    - [一、构造函数的基本用法](#一构造函数的基本用法)
      - [1、构造函数概念](#1构造函数概念)
      - [2、构造函数的特点](#2构造函数的特点)
      - [3、构造函数的分类](#3构造函数的分类)
      - [4、在类内定义构造函数（基本用法）](#4在类内定义构造函数基本用法)
    - [二、带参构造函数与其调用](#二带参构造函数与其调用)
      - [1、带参构造函数](#1带参构造函数)
      - [2、有参构造 实例](#2有参构造-实例)
      - [3、初始化列表](#3初始化列表)
      - [4、有默认参数的构造函数](#4有默认参数的构造函数)
    - [三、拷贝构造函数](#三拷贝构造函数)
      - [1、概念](#1概念)
      - [2、自定义拷贝构造函数](#2自定义拷贝构造函数)
      - [3、匿名对象（少用）](#3匿名对象少用)
      - [4、显示法调用构造函数（实例化）](#4显示法调用构造函数实例化)
      - [5、隐式法调用构造函数（实例化）](#5隐式法调用构造函数实例化)
    - [四、构造函数的重载](#四构造函数的重载)
    - [五.构造函数例子](#五构造函数例子)
      - [1.例子一](#1例子一)
  - [命名空间-namespace](#命名空间-namespace)
    - [一.为什么需要命名空间](#一为什么需要命名空间)
    - [二.什么是命名空间](#二什么是命名空间)
    - [三.使用命名空间解决名字冲突](#三使用命名空间解决名字冲突)
    - [四.使用命名空间成员的方法](#四使用命名空间成员的方法)
    - [五.无名的命名空间](#五无名的命名空间)
    - [六.标准命名空间std](#六标准命名空间std)
    - [总结](#总结)
  - [作用域与可见性](#作用域与可见性)
    - [一.总概述](#一总概述)
    - [二.作用域的分类](#二作用域的分类)
      - [1.概述](#1概述)
      - [2.名字空间作用域](#2名字空间作用域)
        - [2.1名字空间的意义](#21名字空间的意义)
        - [2.2名字空间的定义](#22名字空间的定义)
        - [2.3名字空间成员的定义](#23名字空间成员的定义)
        - [2.4名字空间成员的使用](#24名字空间成员的使用)
        - [2.5标准名字空间std](#25标准名字空间std)
        - [2.6名字空间的嵌套](#26名字空间的嵌套)
        - [2.7未命名名字空间](#27未命名名字空间)
  - [C++中类的(static)静态成员和类的(static)静态成员函数](#c中类的static静态成员和类的static静态成员函数)
    - [1.语法](#1语法)
    - [2.类的静态成员的目的](#2类的静态成员的目的)
    - [3.类的静态数据成员和静态成员函数](#3类的静态数据成员和静态成员函数)
    - [4.具有静态数据成员的类](#4具有静态数据成员的类)
    - [5.具有静态数据和成员函数的Point类](#5具有静态数据和成员函数的point类)
  - [友元](#友元)
    - [1.介绍](#1介绍)
    - [2.友元函数](#2友元函数)
    - [3.友元类](#3友元类)
  - [共享数据保护](#共享数据保护)
    - [1.常引用作形参](#1常引用作形参)
    - [2.常对象](#2常对象)
    - [3.用const修饰的类成员](#3用const修饰的类成员)
    - [4.常引用](#4常引用)
  - [项目一般组织结构](#项目一般组织结构)
    - [1.组织结构](#1组织结构)
    - [2.类对象结构演示](#2类对象结构演示)
  - [C++类的对象数组](#c类的对象数组)
    - [一.对象数组的定义](#一对象数组的定义)
    - [二.对象数组初始化](#二对象数组初始化)
      - [2.1构造函数有0个或1个参数](#21构造函数有0个或1个参数)
      - [2.2构造函数有多个参数](#22构造函数有多个参数)
  - [类的继承与派生](#类的继承与派生)
    - [一、概念与定义](#一概念与定义)
      - [1.继承的概念与定义](#1继承的概念与定义)
      - [2.继承与派生的实现](#2继承与派生的实现)
      - [3.派生类的生成过程](#3派生类的生成过程)
      - [4.继承方式](#4继承方式)
        - [公有继承](#公有继承)
        - [私有继承](#私有继承)
  - [多态性](#多态性)
    - [一、多态性的概念](#一多态性的概念)
    - [二、静态多态性](#二静态多态性)
      - [（1）函数重载](#1函数重载)
        - [1.函数重载的概念](#1函数重载的概念)
        - [2.判断函数重载的规则](#2判断函数重载的规则)
        - [3.函数重载解析的步骤](#3函数重载解析的步骤)
        - [4.名字粉碎（名字修饰）](#4名字粉碎名字修饰)
        - [5.函数重载的依据](#5函数重载的依据)
      - [（2）运算符重载](#2运算符重载)
        - [1.运算符重载的实质](#1运算符重载的实质)
        - [2.运算符重载的规则和限制](#2运算符重载的规则和限制)
        - [3.运算符函数](#3运算符函数)
          - [运算符函数的声明形式：](#运算符函数的声明形式)
          - [运算符成员函数的设计:](#运算符成员函数的设计)
        - [4.运算符友元函数](#4运算符友元函数)
      - [（3）模板](#3模板)
        - [1.什么是c++的模板](#1什么是c的模板)
        - [2.模板的概念](#2模板的概念)
        - [3.函数模板](#3函数模板)
          - [3.1什么是函数模板](#31什么是函数模板)
          - [3.2函数模板的定义格式](#32函数模板的定义格式)
          - [3.3案例](#33案例)
          - [3.4函数模板的实例化](#34函数模板的实例化)
          - [3.5函数模板的重载](#35函数模板的重载)
          - [3.6函数模板与普通函数小结](#36函数模板与普通函数小结)
          - [3.7使用函数模板要注意的问题](#37使用函数模板要注意的问题)
        - [4.类模板](#4类模板)
          - [4.1定义类模板的格式](#41定义类模板的格式)
          - [4.2类与类模板的关系](#42类与类模板的关系)
          - [4.3类模板的实例化](#43类模板的实例化)
        - [5.类模板与友元函数](#5类模板与友元函数)
          - [5.1非模板友元函数](#51非模板友元函数)
          - [5.2约束模板友元函数](#52约束模板友元函数)
          - [5.3非约束模板友元函数](#53非约束模板友元函数)
    - [三、动态多态性](#三动态多态性)
      - [(1)动态多态性的定义及实现](#1动态多态性的定义及实现)
        - [1.重写/覆盖 的要求](#1重写覆盖-的要求)
        - [2.多态两个要求](#2多态两个要求)
        - [3.多态的切片示意图](#3多态的切片示意图)
        - [4.多态演示](#4多态演示)
        - [5.虚函数重写的例外](#5虚函数重写的例外)
        - [6.接口继承和实现继承](#6接口继承和实现继承)
        - [7.析构函数的重写](#7析构函数的重写)
        - [8.override 和 final](#8override-和-final)
        - [9.重载、覆盖(重写)、隐藏(重定义)的对比](#9重载覆盖重写隐藏重定义的对比)
        - [10.抽象类](#10抽象类)
      - [（2）动态多态性的实现原理](#2动态多态性的实现原理)
        - [1.虚函数](#1虚函数)
  - [11.流类库与输入输出](#11流类库与输入输出)
    - [11.1I/O流的概念及流类库结构](#111io流的概念及流类库结构)
    - [11.2输出流](#112输出流)
      - [11.2.1构造输出流对象](#1121构造输出流对象)
      - [11.2.2使用插入运算符和操纵符](#1122使用插入运算符和操纵符)
      - [11.2.3文件输出流函数](#1123文件输出流函数)
      - [11.2.4二进制输出文件](#1124二进制输出文件)
      - [11.2.5字符串输出流](#1125字符串输出流)
    - [11.3 输入流](#113-输入流)
      - [11.3.1构造输入流对象](#1131构造输入流对象)
      - [11.3.2使用提取运算符](#1132使用提取运算符)
      - [11.3.3输入流操作符](#1133输入流操作符)
      - [11.3.4输入流相关函数](#1134输入流相关函数)
      - [11.3.5字符串输入流](#1135字符串输入流)
    - [11.4输入输出流](#114输入输出流)






## 1.介绍与引入
C++是一种面向对象的编程语言，它在C语言的基础上发展而来，增加了许多强大的特性，使得开发者能够编写更加高效、模块化和可维护的代码。

### 1.1关键特性

C++的一些关键特性：
1. **面向对象编程（OOP）**：C++支持类和对象的概念，允许数据封装、继承和多态。这有助于模拟现实世界中的实体和关系，提高代码的复用性和灵活性。
2. **类与对象**：类是定义对象属性（数据成员）和行为（成员函数）的蓝图。对象则是类的实例，具体实现类定义的功能。
3. **封装**：通过将数据和操作这些数据的函数封装在类中，隐藏了内部实现细节，只暴露公共接口给外部使用，提高了代码的安全性和模块化。
4. **继承**：一个类可以从另一个类派生，继承其属性和方法，并可以添加或修改它们，实现了代码的复用。
5. **多态**：允许使用一个接口以表示不同类型的实体，从而实现接口的多种不同行为。C++中的多态主要通过虚函数和抽象类来实现。
6. **模板**：C++引入了泛型编程的概念，允许程序员编写与类型无关的代码。模板可以用于类（类模板）和函数（函数模板），提高了代码的通用性。
7. **标准模板库(STL)**：STL是一个功能强大的库，包括容器（如vector, list, map等）、算法（如sort, search等）和迭代器，极大地方便了编程并提高了效率。
8. **异常处理**：C++提供了异常处理机制，使用try-catch语句捕获和处理程序运行时可能出现的错误，增强了程序的健壮性。
9. **命名空间**：命名空间用于组织代码，避免全局命名冲突，使得大型项目中的不同部分可以使用相同的标识符而不互相干扰。
10. **运算符重载**：允许程序员改变运算符的行为，使之适用于自定义的数据类型，使代码更自然易读。
11. **RAII（Resource Acquisition Is Initialization）**：这是一种管理资源（如内存、文件句柄）的技术，通过构造函数获取资源，在析构函数中释放资源，保证了资源的正确管理和异常安全。


C++的这些特性使其成为开发高性能应用、系统软件、游戏引擎、实时系统等多种领域应用的优选语言。


### 1.2知识点总清单

章节知识点目录：  

+ `C++预备知识`
+ `函数`
+ `类与对象`
+ `数据共享与保护`
+ `数组、指针与字符串`
+ `类的继承与派生`
+ `多态性`
+ `模板与群体数据`
+ `STL库`
+ `流类库与输入输出`
+ `异常处理` 

**重点需要关注的知识点：**  

+ 指针与引用的区别
+ C 与 C++ 的区别
+ `struct` 与 `class` 的区别
+ `struct` 内存对齐问题
+ `sizeof`与 `strlen` 区别
+ 面向对象的三大特性：封装、继承、多态
+ 类的访问权限：`private`、`protected`、`public`
+ 类的构造函数、析构函数、赋值函数、拷贝函数
+ 移动构造函数与拷贝构造函数对比
+ 内存分区：全局区、堆区、栈区、常量区、代码区
+ 虚函数实现动态多态的原理、虚函数与纯虚函数的区别
+ 深拷贝与浅拷贝的区别
+ 一些关键字：`static`, `const`, `extern`, `volatile` 等
+ 四种类型转换：`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`
+ 静态与多态：重写、重载、模板
+ 四种智能指针及底层实现：`auto_ptr`、`unique_ptr`、`shared_ptr`、`weak_ptr`
+ 右值引用
+ `std::move`函数
+ 迭代器原理与迭代器失效问题
+ 一些重要的`STL`：`vector`, `list`, `map`, `set` 等。
+ 容器对比，如 `map` 与 `unordered_map` 对比，`set `与 `unordered_set` 对比，`vector` 与 `list` 比较等。
+ STL容器空间配置器

## 2.C++预备知识（C语言基础与C++新特性）

本章节知识点目录：
+ 字符集
+ 关键字
+ 标识符
+ 文字
+ 操作符（运算符）
+ 分隔符
+ 空白符
+ 基本数据类型
+ 常量
+ 变量
+ 符号常量
+ constexpr与常量表达式
+ 运算符与表达式
+ 语句
+ 

### 2.1字符集
字符集是构成C++语言的基本元素，用C++语言编写编写程序时
，除字符类型外，其他所有成分都只能由字符集中的字符构成。
C++语言支持以下字符集：
+ ASCII字符集
+ ISO8859-1字符集
+ Unicode字符集
+ UTF-8字符集
+ UTF-16字符集


未完待续......



### 2.2关键字

C++的常用关键字包括：`auto`、`decltype`、`bool`、`throw`、`try`、`catch`、`class`、`constexpr`、`new`、`delete`、`const_cast`、`static_cast`、`dynamic_cast`、`reinterpret_cast`、`explicit`、`export`、`friend`、`mutable`、`using`、`namespace`、`noexcept`、`nullptr`、`operator`、`private`、`protected`、`public`、`static_assert`、`template`、`typename`、`this`、`thread_local`、`typeid`、`virtual`等。  


我们结合代码示例来介绍各个关键字。

目录
1. `auto`自动推断变量
2. `decltype`推断变量类型
3. `bool`布尔变量
4. `throw`/`try`/`catch`异常处理
5. `class`类与对象
6. `constexpr`常量表达式
7. `new`与`delete`管理对象
8. 类型转换
9. `explicit`显式调用
10. `export`全局引用
11. `friend`友元函数
12. `mutable`可变变量
13. `namespace`命名空间
14. `noexcept`禁止异常
15. `nullptr`空指针
16. `private`、`protected`和`public`
17. `typeid`获取类型信息
18. `operator`重载操作符
19. `template`模板
20. `this`指针
21. `thread_local`线程私有
22. `virtual`虚函数


#### 2.2.1auto自动推断变量
`auto`根据变量初始化来推断变量类型。示例如下：
```cpp
auto array = new int[8];
```

#### 2.2.2decltype推断变量类型
与`auto`不同的是，`decltype`是根据表达式来推断变量类型。语法格式如下：
```cpp
decltype(expression) var;
```
表达式包括：变量、运算、函数等，示例如下：
```cpp
long add() {
    return 0;
}
 
void hello() {
    int a = 2;
    decltype(a) b; // b为int类型
    decltype(add()) c; // c为long类型
}
```

#### 2.2.3bool布尔变量
`bool`关键字表示布尔变量，只有`true`或`false`两种变量值。

#### 2.2.4throw/try/catch异常处理
使用关键字`throw`抛出异常，使用`try`/`catch`来捕获异常。示例代码如下：
```cpp
try {
    std::string msg("This is a test exception");
    throw msg;
} catch (const std::string &e) {
    printf("exception=%s", e.c_str());
}
```

#### 2.2.5class类与对象
C++的类与java类相似，都是面向对象编程。类的声明示例如下：
```cpp
#include <string>
 
class Person {
private:
    int m_age;
    std::string m_name;
public:
    void setAge(int age);
    int getAge();
    void setName(const std::string &name);
    std::string getName();
};
```
对应的类实现如下：
```cpp
#include "Person.h"
 
void Person::setAge(int age) {
    m_age = age;
}

int Person::getAge() {
    return m_age;
}

void Person::setName(const std::string &name) {
    m_name = name;
}

std::string Person::getName() {
    return m_name;
}
```


创建Person类的对象实例：
```cpp
auto person = new Person();
person->setAge(10);
person->setName("frank");
printf("name=%s, age=%d", person->getName().c_str(), person->getAge());
```


#### 2.2.6constexpr常量表达式
`constexpr`只能修饰带有return的函数。在C++20增加了`consteval`修饰常量表达式，不同的是，在编译期确定参数类型。示例如下：
```cpp
constexpr int hello(int a, int b) {
    return a + b;
}
```
另外，函数体内不能有赋值运算，否则有如下报错：
```
subexpression not valid in a constant expression
```

#### 2.2.7new与delete管理对象
在C++提供关键字`new`来创建对象，`delete`释放对象。在C语言是用库函数`malloc`来申请内存，`free`来释放内存。要注意的是，释放数组需要加上[]。示例如下：
```cpp
// 创建对象
auto person = new Person();
// 释放对象
delete person;
// 创建数组
auto array = new int[8];
// 释放数组
delete[] array;
```


#### 2.2.8类型转换
C++提供`const_cast`、`static_cast`、`dynamic_cast`和`reinterpret_cast`四种类型转换，如下所示：


+ `const_cast`:用于修改const属性，接受指针或引用类型  
+ `static_cast`:用于基本类型转换  
+ `dynamic_cast`:用于有继承关系的类指针转换，支持类型检查  
+ `reinterpret_cast`:用于指针类型转换  


类型转换的示例代码如下：
```cpp
// const_cast用于const属性
const int a = 10;
int &b = const_cast<int &> (a);
// static_cast基本类型转换
float x = 10.5f;
int y = static_cast<int> (x);
// dynamic_cast用于子类与父类转换
SuperMan *superman = new SuperMan();
superman->setAge(100);
Person *person = dynamic_cast<Person*> (superman);
// reinterpret_cast用于指针类型转换
void *data = (void *) "hello";
char *new_data = reinterpret_cast<char *> (data);
```


#### 2.2.9explicit显式调用
explicit用于修饰单参数的构造函数，被修饰的构造函数只能被显式调用，不能被隐式调用。示例如下：
```cpp
class Person {
private:
    int m_age;
public:
    explicit Person(int age);
};
```

#### 2.2.10export全局引用
C语言有extern关键字用于声明全局变量，但是C++的模板没法用extern修饰。因此，提供export修饰在头文件声明的模板类或模板函数，其他源文件只要引用该头文件即可使用模板类或模板函数。


#### 2.2.11friend友元函数
friend关键字把函数声明为友元函数。声明函数为外部类的友元函数后，外部类可以通过友元函数访问该类的私有成员。示例代码如下：
```cpp
class Pointer;
 
class Calculator {
public:
    Pointer* add(Pointer &a, Pointer &b);
};
 
class Pointer {
    // 声明为Calculator的友元函数
    friend Pointer* Calculator::add(Pointer &a, Pointer &b);
private:
    int m_x;
    int m_y;
public:
    Pointer(int x, int y);
};
 
// Calculator访问Pointer的私有成员，通过对象访问
Pointer* Calculator::add(Pointer &a, Pointer &b) {
    return new Pointer(a.m_x + b.m_x, a.m_y + b.m_y);
}
```

#### 2.2.12mutable可变变量
mutable用于且只能修饰类的成员变量，与const修饰常量相反。比如，constexpr修饰的常量表达式不允许修改成员变量，而成员变量添加mutable修饰符后可修改。示例如下：
```cpp
class Person {
    
private:
    mutable int m_age; 
public:
    explicit Person(int age);
    constexpr int getAge();
 
};
 
constexpr int Person::getAge() {
    m_age += 10; // 修改成员变量
    return m_age;
}
```
非成员变量使用mutable修饰符会报错如下：
```
'mutable' can only be applied to member variable
```


#### 2.2.13namespace命名空间
 命名空间用于模块隔离，避免模块之间命名冲突。示例代码如下：
```cpp
namespace Learning {
    class Person {
 
    private:
        std::string m_name;
    public:
        void setName(const std::string &name);
        std::string getName();
    };
}
```
使用using引用命名空间，需要注意的是遵循最小原则。示例如下：
```cpp
// 直接命名空间引用
Learning::Person *person1 = new Learning::Person();
// 引入命名空间
using namespace Learning;
Person *person2 = new Person();
```

#### 2.2.14noexcept禁止异常
使用`noexcept`修饰函数禁止抛出异常，防止错误扩散。示例如下：
```cpp
std::string getName() noexcept;
```

#### 2.2.15nullptr空指针
在C语言使用`NULL`表示空指针，java使用`null`表示空指针，Object-C使用`nil`表示空指针。当然，今天的主角是C++，它使用`nullptr`表示空指针。


#### 2.2.16private、protected和public
与java类似，C++提供`private`、`protected`和`public`访问修饰符，可以修饰类、函数、变量。三者对比如下：

+ private	类内部访问
+ proteted	有继承关系的类可访问
+ public	类外部都可以访问

#### 2.2.17typeid获取类型信息
`typeid`用于获取类型信息的操作符，使用示例如下：
```cpp
typeid(a).name()
```
基本类型对应的类型信息如下:

基本类型/类型信息  
+ int	i
+ char	c
+ short	s
+ double d
+ float	f
+ long	l



#### 2.2.18operator重载操作符
在C++中，字符串能够进行加法运算或比较运算，是因为使用`operator`重载。我们来看下重载加法运算的示例：
```cpp
class Point {

private:
    int m_x;
    int m_y;
public:
    Point(int x, int y);
    int getX();
    int getY();
    // 重载加法运算
    Point operator +(const Point &p) const {
        return {m_x + p.m_x, m_y + p.m_y};
    }
};
```
然后调用Point类的加法：
```cpp
Point p1(1, 2);
Point p2(2, 3);
Point point = p1 + p2;
printf("point.x=%d, point.y=%d\n", point.getX(), point.getY());
```

#### 2.2.19template模板
`template`可以用于模板类或模板方法，支持不同数据类型的方法复用。示例如下：
```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```
然后分别是int类型与float类型的加法运算：
```cpp
int a = 2, b = 3;
int result1 = add(a, b);
printf("int add=%d\n", result1);
float c = 2.5f, d = 3.5f;
float result2 = add(c, d);
printf("float add=%f\n", result2);
```

#### 2.2.20this指针
`this`指针在类内部使用，可以访问类的所有成员。示例如下：
```cpp
Point::Point(int x, int y) {
    this->m_x = x;
    this->m_y = y;
}
```


#### 2.2.21thread_local线程私有
`thread_local`用于表示线程私有变量，即每个线程都会存储一个变量的值，线程之间互不共享，是C++提供的存储期关键字。

与`thread_local`类似的存储期关键字还有：    
`auto`、`register`、`static`、`extern`.


各个关键字对比如下：
+ auto	自动存储期
+ register	自动存储期，位于寄存器
+ static	静态存储期
+ extern	程序存储期，全局使用
+ thread_local	线程存储期，线程私有


#### 2.2.22virtual虚函数
虚函数是C++的多态机制，使用`virtual`关键字声明，允许通过基类指针访问基类与派生类的同名函数。基类的析构函数需要声明为虚函数，否则调用不到派生类的析构函数，导致内存泄漏。  

示例代码如下：

```cpp
class Animal {
protected:
    std::string m_name;
public:
    Animal(const std::string &name);
    // 析构函数声明为虚函数
    virtual ~Animal();
};
 
class Cat : public Animal {
public:
    Cat(const std::string &name);
    ~Cat();
};
```

基类与派生类的实现：

```cpp
Animal::Animal(const std::string &name) {
    m_name = name;
}
 
Animal::~Animal() noexcept {
    printf("Animal release\n");
}
 
Cat::Cat(const std::string &name) : Animal(name) {
    m_name = name;
}
 
Cat::~Cat() noexcept {
    printf("Cat release\n");
}
```

测试代码，创建Cat类，然后释放：
```cpp
Animal *cat = new Cat("cat");
delete cat;
```

打印输出如下，先调用派生类析构函数，再调用基类析构函数：
```
Cat release
Animal release
```

### 2.3标识符
标识符是程序员定义的单词，它命名程序正文中的一些实体，如函数名、变量名、类名、对象名等。   

C++语言标识符的构成规则：  

+ 以大写字母、小写字母或者下划线开头（不能是数字），后面可以跟任意字母、数字、下划线。
+ 大写字母和小写字母可以代表不同的标识符。
+ 不能是C++语言关键字或操作符。

注意： `override`，`final`标识符在特定上下文中有特殊含义，将被用作语法标志而并非普通标识符。类似地C++还有一些标识符保留给标准库，这些应尽量避免使用。

### 2.4操作符（运算符）
操作符是用于实现各种运算的符号，例如：+、——、*、/、%、=、==、!=、<、>、<=、>=、++、--、!、&&、||、&、|、^、~、<<、>>、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=、->、->*、[]、()、new、delete、new[]、delete[]、typeid、dynamic_cast、static_cast、reinterpret_cast、const_cast、sizeof、alignof、noexcept、

C++中，还提供了一些操作符的替代名：
`and`,`andeq`,`bitand`,`bitor`,`compl`,`not`,`not_eq`,`or`,`or_eq`,`xor`,`xor_eq`


### 2.5分隔符
分隔符用于分隔各个词法记号或程序正文，C++语言中的分隔符是：  

`;`  `:`  `,`  `{}`  `()`


### 2.6空白符
在程序编译时的词法分析阶段将程序正文分解为词法记号，空白符将被忽略。

**空白符**：空格、制表符、换行符、回车符、换页符、垂直制表符。


### 2.7基本数据类型
![alt text](C++基本数据类型.jpg)

C++中基本数据类型：
1. 整型：int、long、long long
2. 浮点型：float、double、long double
3. 字符型：char、wchar_t
4. 布尔型：bool
5. 字符串型：string、wstring（不属于基本数据类型）
6. 枚举型：enum

`int`型（也包括short和long）在默认（不加修饰）情况下是有符号的（signed）的。


### 2.8常量
常量是指在程序运行整个过程中其值始终不改变的量，也就是直接使用符号（文字）表示的值。例如：  

`12`,`3.5`,`A`都是常量

#### 2.8.1整型常量

+ 指以**文字形式出现的整数**，包括**正整数、负整数和零**。
+ 整型常量的表现形式有**十进制、八进制和十六进制**。
+ 八进制以数字“0”开头，十六进制以数字“0x”或“0X”开头。十六进制的整型常量的数字部分要“0x”开头，加上若干个0~9的数字及“a”到“f”的小写字母或“A”到“F”的大写字母表示。
+ 默认情况下，十进制整型常量是带符号数，八进制和十六进制整型常量既可能是带符号也可能是无符号数。
+ 十进制整型常量的类型是`int`，`long`，`long long`钟能容纳其数值的尺寸中最小的一个，八进制和十六进制整型常量的类型则是能容纳其数值的`int`,`unsigned int`,`unsigned long`,`long long`,`unsigned long long`钟能容纳其数值的尺寸中最小的一个。
+ 整型常量可以用后缀指定他是否带符号以及占用多少空间：后缀L（或l）表示类型至少是`long`，后缀LL（或ll）表示类型是`long long`,后缀U（或u）表示unsigned类型。

#### 2.8.2实型常量
实型常量即**以文字形式出现的实数**，实数有两种表示形式：
1. 一般形式：例如：12.5，-12.5等。
2. 指数形式：例如：1.2e-3，-1.2e-3等。**e可以是大写也可以是小写**。

**注意**：实型常量**默认为double型**，如果后缀"F"（或“f”）可以使其成为float型，例如“12.3f”。

#### 2.8.3字符常量
字符常量是**单引号括起来的一个字符**，如：'a'，'A'，'$','?'等。

另外还有一些无法通过键盘输入，例如响铃，换行，制表符，回车等。这些字符常量该如何写入程序中呢？

**使用转义字符或者ASCLL码来实现。**

![Alt text](C语言中的转义字符.png)

例如：   
'a'的十六进制ASCLL码为61，于是可以用\x61来表示。

**注意**：字符数据在内存中以ASCLL码的形式存储，每个字符占用一个字节，使用7个二进制位。

#### 2.8.4字符串常量
字符串常量简称字符串，是用一对双引号括起来的字符序列，如："Hello World!"。都是字符串常量。

1. 字符串常量是存储在只读区中的，不能修改。
2. 字符串和字符是不同的，它在内存中的存放形式是：按串中的字符的排列次序顺序存放，每个字符占一字节，并在末尾添加'\0'
作为结束标记。
3. 通过添加前缀可以改变字符常量或者字符串常量的类型，前缀及其含义如下所示：

+ `u`,unicode 16 字符，char16_t
+ `U`,unicode 32 字符，char32_t
+ `L`,宽字符，wchar_t
+ `u8`,UTF-8字符()，char

**注意**："a"和'a'的区别是："a"是字符串常量，'a'是字符常量。   
`"a"`:a,\0   
`'a'`:a

#### 2.8.5布尔常量
布尔型常量只有两个：false（假）和true（真）。


### 2.9变量
在程序的执行过程中其值可以发生改变的量称为变量，变量是需要名字来标识的。

#### 2.9.1变量的声明和定义
就像常量具有各种类型一样，变量也具有相应的类型，变量在使用前需要首先申明其类型和名称。 



未完待续。。。


#### 2.9.2变量的初始化
在定义一个变量的同时，也可以为它设置初始值，称为对变量的初始化，例如：
```cpp
int a=3;
double f=3.14;
char c='a';
```
知识点：
+ 用于初始化的变量的值可以是**任意的表达式**，在同一条定义语语句钟可以用先定义的变量值去初始化后定义的其他变量。
```cpp
double pi=3.14,c=3*pi;
```
+ **初始化和赋值是不同的**,初始化是在创建变量时赋予其一个初始值，赋值是在变量已经创建之后，对变量当前的值擦去，用一个新的值代入。
+ 多种初始化方式
```cpp
int a=0;
int a(0);
int a{0};
int a={0};
```
+ 其中使用花括号的初始化方式称为**列表初始化**。列表初始化的使用条件较为严格，必须保证初始化列表中的每个元素类型与变量类型一致。
```cpp
double pi=3.14;
int a{pi},b={pi};//错误，转换未执行，存在丢失信息的风险
int c(pi),d=pi;//正确，转换执行，不存在丢失信息的风险
```
+ 如果定义变量时没有指定初始值，那么变量会被默认初始化，变量被赋予了“默认值”，这个值由**变量类型**和**定义变量的位置**有关。
+ 如果没有被显式初始化，它的值将由定义的位置决定。**定义于任何函数体外的变量被初始化为0**；定义在函数体内部的基本数据类型将不被初始化，一个未被初始化的基本数据类型变量的值是**未定义的**，如果试图复制或者以其他形式访问这类值会引发错误。


#### 2.9.3变量的存储类型
变量除了具有数据类型外，还有具有**存储类型**。 

变量的存储类型决定了其存储方式:
+ register：寄存器变量，变量的值存放在**处理器的通用寄存器**中，变量的值在每次使用前都需要从寄存器中读取，变量的值在每次使用后都需要写入到寄存器中。
+ extern存储类型：**在所有的函数和程序段中都可以引用**。外部变量，变量的值存放在程序的其他地方，变量的值在每次使用前都需要从外部变量中读取，变量的值在每次使用后都需要写入到外部变量中。
+ static存储类型：静态变量，**在内存中以固定地址存放，在整个程序运行期间都有效**。变量的值存放在程序的静态存储区中，变量的值在每次使用前都需要从静态存储区中读取，变量的值在每次使用后都需要写入到静态存储区中。
+ mutable存储类型：可变变量，**只能用于类数据成员**，并且**不能与const或者static同时使用，也不能用来修饰引用变量**。mutable修饰的类数据成员会使其const属性无效并允许更改mutable类型的数据成员，但对象中其余成员仍是const类型的。 变量的值存放在程序的栈中，变量的值在每次使用前都需要从栈中读取，变量的值在每次使用后都需要写入到栈中，但是可变变量的值可以在每次使用后被修改。
+ thread_local存储类型：线程局部变量，**具有线程存储生存期**。thread_local只能用来修饰**命名空间以及块作用域变量**或者**已经被指定为static存储类型的变量**。它的值存放在程序的线程存储区中，变量的值在每次使用前都需要从线程存储区中读取，变量的值在每次使用后都需要写入到线程存储区中。具有thread_local存储类型的变量，必然具有static类型的性质，不管是否使用了static关键字。


### 2.10符号常量
除了前面讲过的直接用文字表示常量外，也可以为常量命名，这就是符号常量。


**符号常量在使用之前一定要首先声明**
```
const 数据类型说明符 常量名 = 常量值;
或
数据类型说明符 const 常量名 = 常量值;
```
例：
```
const float PI=3.1415926;
```
**注意：符号常量在声明时一定要初始化，而在程序中间不能改变其值。**，例如下列语句是错误的：
```cpp
const float PI;//错误，常量在声明时必须被初始化
PI=3.1415926;//错误，常量不能改变其值
```

意义：
1. 与直接使用文字量相比，给常量取个名字可以提高程序的可读性
2. 使用常量后可以减少程序中重复使用的文字量，且方便修改从而有利于提高程序的可维护性。



### 2.11constexpr与常量表达式
常量表达式是一类值不能发生改变的表达式，其值在编译期就确定。
```cpp
const int_max_size=100;
const int limit=int_max_size+1;
int student_size=30;//student_size
const int size=get_size();//不是常量表达式
```

在实际编程中会用constexpr来表示常量表达式。


未完待续



### 2.12运算符与表达式

#### *操作符的分类
+ 算术操作符： `+ 、- 、* 、/ 、%`
+ 移位操作符: `<< >>`
+ 位操作符: `& | ^`
+ 赋值操作符:` = 、+= 、 -= 、 *= 、 /= 、%= 、<<= 、>>= 、&= 、|= 、^=`
+ 单⽬操作符:`！、++、--、&、*、+、-、~ 、sizeof、(类型)`
+ 关系操作符:` > 、>= 、< 、<= 、 == 、 !=`
+ 逻辑操作符：`&& 、||`
+ 条件操作符：`? :`
+ 逗号表达式：`,`
+ 下标引⽤：`[]`
+ 函数调⽤：`()`
+ 结构成员访问：`. 、->`

#### 2.12.1算术操作符(双目)
有`+、-、*、/、%`这些  

其中`/`是除运算,`%`是取模(取余数)运算.  

这些操作符都是**双目操作符**。
他们都是有2个操作数的，位于操作符两端的就是它们的操作数，这种操作符也叫双目操作符。

+ \除运算

演示
```c
int main()
{
    int a = 7 / 2;
    //如果是float a =7/2,结果为3.0，原因就在于 C 语⾔⾥⾯的整数除法是整除，只会返回整数部分，丢弃⼩数部分。
    printf("%d\n",a);
    float b =7 / 2.0;
    printf("%f\n",b);//除号两端都是整数的时候,执行的是整数除法,如果两端只要有一个浮点数就执行浮点数的除法.
    printf("%.1f\n",b);//结果保留一位小数,`.2`则表示保留两位,以此类推.
}
```
再看⼀个例子：
```c
#include <stdio.h>
int main()
{
   int score = 5;
   score = (score / 20) * 100;
   return 0;
}
//结果为0
```
上⾯的代码，你可能觉得经过运算， score 会等于 25 ，但是实际上 score 等于 0 。这是因为
score / 20 是整除，会得到⼀个整数值 0 ，所以乘以 100 后得到的也是 0 。
为了得到预想的结果，可以将除数 20 改成 20.0 ，让整除变成浮点数除法。
```c
#include <stdio.h>
int main()
{
   int score = 5;
   score = (score / 20.0) * 100;
   return 0;
}
//结果为0
```


+ %取模运算

运算符 % 表⽰求模运算，即返回两个整数相除的余值。这个运算符只能⽤于整数，不能⽤于浮点数。
```c
int c = 7 % 2;
printf("%d\n",c);//取模是不能写浮点数的
```
负数求模的规则是，结果的正负号由第⼀个运算数的正负号决定。
```c
#include <stdio.h>
int main()
{
   printf("%d\n", 11 % -5); // 1
   printf("%d\n",-11 % -5); // -1
   printf("%d\n",-11 % 5); // -1
   return 0;
}
```
上⾯⽰例中，第⼀个运算数的正负号（ 11 或 -11 ）决定了结果的正负号。


#### 2.12.2移位操作符
`<<` 左移操作符  
`>>`右移操作符  
`>>` `<<` (涉及二进制)  
注：移位操作符的操作数只能是整数。




##### 左移操作符
移位规则：左边抛弃、右边补0
```c
#include <stdio.h>
int main()
{
    int num = 10;
    int n = num<<1;//num的值是不变的
    printf("n= %d\n", n);
    printf("num= %d\n", num);
    return 0;
}
```
##### 右移操作符

移位规则：首先右移运算分两种：
> 1.逻辑右移：左边用0填充，右边丢弃  
> 2.算数右移：左边用原该值的符号位填充，右边丢弃

![alt text](算术位移.png)

注意：对于移位运算符，不要移动负数位，这个是标准未定义的。


#### 2.12.3位操作符
`& ^ | ~`
按位与  
按位或  
按位异或  
按位取反  
注：他们的操作数必须是整数。

```c
#include <stdio.h>
int main()
{
    int num1 = -3;
    int num2 = 5;
    printf("%d\n", num1 & num2);
    printf("%d\n", num1 | num2);
    printf("%d\n", num1 ^ num2);
    printf("%d\n", ~0);
    return 0;
}
```
⼀道变态的⾯试题：
不能创建临时变量（第三个变量），实现两个整数的交换。
```c
#include <stdio.h>
int main()
{
    int a = 10;
    int b = 20;
    a = a^b;
    b = a^b;
    a = a^b;
    printf("a = %d b = %d\n", a, b);
    return 0;
}
```

练习1：编写代码实现：求⼀个整数存储在内存中的⼆进制中1的个数。
```c
//⽅法1
#include <stdio.h>
int main()
{
    int num = 10;
    int count= 0;//计数
    while(num)
    {
        if(num%2 == 1)
            count++;
        num = num/2;
    }
    printf("⼆进制中1的个数 = %d\n", count);
    return 0;
}


//⽅法2：
#include <stdio.h>
int main()
{
    int num = -1;
    int i = 0;
    int count = 0;//计数
    for(i=0; i<32; i++)
    {
        if( num & (1 << i) )
            count++; 
    }
    printf("⼆进制中1的个数 = %d\n",count);
    return 0;
}


//⽅法3：
#include <stdio.h>
int main()
{
    int num = -1;
    int i = 0;
    int count = 0;//计数
    while(num)
    {
        count++;
        num = num&(num-1);
    }
    printf("⼆进制中1的个数 = %d\n",count);
    return 0;
}
//这种⽅式是不是很好？达到了优化的效果，但是难以想到。
```

练习2：⼆进制位置0或者置1  

编写代码将13⼆进制序列的第5位修改为1，然后再改回0  
```c
13的2进制序列： 00000000000000000000000000001101
将第5位置为1后：00000000000000000000000000011101
将第5位再置为0：00000000000000000000000000001101
```
参考代码：
```c
#include <stdio.h>
int main()
{
    int a = 13;
    a = a | (1<<4);
    printf("a = %d\n", a);
    a = a & ~(1<<4);
    printf("a = %d\n", a);
    return 0;
}
```













#### 2.12.4赋值操作符
在变量创建的时候给⼀个初始值叫初始化，在变量创建好后，再给⼀个值，这叫赋值。  
```c
int a = 100;//初始化
a = 200;//赋值，这⾥使⽤的就是赋值操作符
```
赋值操作符`=`是⼀个随时可以给变量赋值的操作符。

+ 连续赋值  


赋值操作符也可以连续赋值，如：
```c
int a = 3;
int b = 5;
int c = 0;
c = b = a+3;////连续赋值，从右向左依次赋值的。
```
C语⾔虽然⽀持这种连续赋值，但是写出的代码不容易理解，建议还是拆开来写，这样⽅便观察代码的执⾏细节。

+ 复合操作符  

在写代码时，我们经常可能对⼀个数进⾏⾃增、⾃减的操作，如下代码：
```c
int a = 10;
a += 3;
a -= 2;
```
复合操作符还有
```c
= += -= *= /= &= 

^= |= >>= <<=
```

#### 2.12.5单目操作符
前⾯介绍的操作符都是双⽬操作符，有2个操作数的。C语⾔中还有⼀些操作符只有⼀个操作数，被称为**单目操作符**。 ++、--、+(正)、-(负) 就是单⽬操作符的。

+ ++和--

++是⼀种⾃增的操作符，⼜分为前置++和后置++，--是⼀种⾃减的操作符，也分为前置--和后置--.  

前置`++`
```c
int a = 10;
int b = ++a;//++的操作数是a，是放在a的前⾯的，就是前置++
printf("a=%d b=%d\n",a , b);
```
计算⼝诀：先+1，后使⽤；
a原来是10，先+1，后a变成了11，再使⽤就是赋值给b，b得到的也是11，所以计算技术后，a和b都是11，相当于这样的代码：
```c
int a = 10;
a = a+1;
b = a;
printf("a=%d b=%d\n",a , b);
```

后置`++`
```c
int a = 10;
int b = a++;//++的操作数是a，是放在a的后⾯的，就是后置++
printf("a=%d b=%d\n",a , b);
```
计算⼝诀：先使⽤，后+1
a原来是10，先使⽤，就是先赋值给b，b得到了10，然后再+1，然后a变成了11，所以直接结束后a是11，b是10，相当于这样的代码：
```c
int a = 10;
int b = a;
a = a+1;
printf("a=%d b=%d\n",a , b);
```
同理`--`前置、后置

+ `- `负值  
用来改变数字前的符号.  

+ `+ `正值  
实际上没什么意义.


`& `取地址(和指针有关系)
`*`解引用操作符
`sizeof`是单目操作符,求操作数的类型长度（以字节为单位）
`.`在结构体struct中,`.`为结构成员访问操作符
`->`在结构体struct中,`->`用于连接结构体指针变量和成员名称
```c
int main()
{
    int arr[10] = { 0 };//初始化数组
    printf("%d\n",sizeof(arr));
    //结果为40,计算的是整个数组的大小,单位是字节
    printf("%d\n",sizeof(arr[10]));
    //计算的结果为4,是数组中的一个元素的大小,单位是字节
    printf("%d\n",sizeof(arr)/sizeof(arr[0]));输出的结果为10,是数组元素的个数
    
}

```

`~`  
对一个数的二进制按位取反(后面学)



`*`间接访问操作符(解引用操作符)(后续会解释)

`(类型)`强制类型转换,括号内的类型是想要转换的类型
在c语言中,对于像3.14这样的的字面浮点数,编译器默认理解为double类型
```c
int a = (int)3.14
printf("%d\n",a);
```



#### 2.12.6关系操作符
C 语⾔⽤于⽐较的表达式，称为 “关系表达式”（relational expression），⾥⾯使⽤的运算符就称为“关系运算符”（relational operator），主要有下⾯6个。

+ `>`大于操作符
+ `>=`⼤于等于运算符  
+ `<`⼩于运算符  
+ `<=`⼩于等于运算符  
+ `!=`不相等运算符 
+ `==`相等运算符  

关系表达式通常返回 0 或 1 ，表⽰真假。  
C 语⾔中， 0 表⽰假，所有⾮零值表⽰真。⽐如， 20 > 12 返回 1 ， 12 > 20 返回 0 。 

关系表达式常⽤于 if 或 while 结构。
```c
if (x == 3)
{
   printf("x is 3.\n");
}
```
另⼀个需要避免的错误是：多个关系运算符不宜连⽤。
```c
i < j < k
```
上⾯⽰例中，连续使⽤两个⼩于运算符。这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量j的值在i和 k 之间。因为关系运算符是从左到右计算，所以实际执⾏的是下⾯的表达式。
```c
(i < j) < k
```
上⾯式⼦中， i < j 返回 0 或 1 ，所以最终是 0 或 1 与变量 k 进⾏⽐较。如果想要判断变量j的值是否在 i 和 k 之间，应该使⽤下⾯的写法。
```c
i < j && j < k
```

#### 7.逻辑操作符
+ && 逻辑与  

&& 就是与运算符，也是并且的意思， && 是⼀个双⽬操作符，使⽤的⽅式是 a&&b , && 两边的表达式都是真的时候，整个表达式才为真，只要有⼀个是假，则整个表达式为假。  

+ || 逻辑或  

|| 就是或运算符，也就是或者的意思， || 也是⼀个双⽬操作符，使⽤的⽅式是 a || b ， ||两边的表达式只要有⼀个是真，整个表达式就是真，两边的表达式都为假的时候，才为假。

```c
int main()
{
    int a = 10;
    int b = 4;
    if (a && b)//(a || b)
    {
        printf("hehe\n");
    }
    return 0;
}
```
+ `! `逻辑反操作

c语言中,0表示假  

非0表示真,`!`的作用就是把**假的**变成**真的**,把**真的**变成**假的**
```c
int main()
{
    int flag = 0;//0表示假,非零表示真
    if (!flag)//if语句中默认条件为真时执行
    {
        printf("haha\n");
    }
}
```

练习
闰年的判断
输⼊⼀个年份year，判断year是否是闰年
闰年判断的规则：
1. 能被4整除并且不能被100整除是闰年
2. 能被400整除是闰年
```c
#include <stdio.h>
//代码1
int main()
{
    int year = 0;
    scanf("%d", &year);
    if(year%4==0 && year%100!=0)
        printf("是闰年\n");
    else if(year%400==0)
        printf("是闰年\n");
 
    return 0;
}
//代码2
int main()
{
    int year = 0;
    scanf("%d", &year);
    if((year%4==0 && year%100!=0) ||(year%400==0))
        printf("是闰年\n");
    return 0;
} 
```

##### 短路问题
C语⾔逻辑运算符还有⼀个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满⾜逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。
如前⾯的代码:
```c
if(month >= 3 && month <= 5)
```
表达式中&& 的左操作数是 month >= 3 ，右操作数是 month <= 5 ,当左操作数 month >= 3 的结果是0的时候，即使不判断 month <= 5 ，整个表达式的结果也是0（不是春季）。
所以，对于&&操作符来说，左边操作数的结果是0的时候，右边操作数就不再执⾏。

对于 || 操作符是怎么样呢？我们结合前⾯的代码：
```c
if(month == 12 || month==1 || month == 2)
```
如果month == 12，则不⽤再判断month是否等于1或者2，整个表达式的结果也是1（是冬季）。所以， || 操作符的左操作数的结果不为0时，就⽆需执⾏右操作数。像这种仅仅根据左操作数的结果就能知道整个表达式的结果，不再对右操作数进⾏计算的运算称为**短路求值**。


```c
#include <stdio.h>
int main()
{
    int i = 0,a=0,b=2,c =3,d=4;
    i = a++ && ++b && d++;
    //i = a++||++b||d++;
    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
    return 0;
}
```
两种情况结果分别是
a = 1  
b = 2  
c = 3  
d = 4  
和  
a = 1  
b = 3  
c = 3  
d = 4  

#### 8.条件操作符(三目操作符)
三目操作符,有三个操作数  
`exp1 ? exp2 : exp3`  
注意符号依次是：问号，冒号，分号  

条件操作符的计算逻辑是：如果 exp1 为真， exp2 计算，计算的结果是整个表达式的结果；如果exp1 为假， exp3 计算，计算的结果是整个表达式的结果。  

例子
```c
int a = 10;
int b = 20;
int c = (a > b ? a : b);
```

#### 9.逗号表达式
逗号表达式，就是⽤逗号隔开的多个表达式。  
逗号表达式，从左向右依次执⾏。整个表达式的结果是最后⼀个表达式的结果。


下面代码的结果是：
```c
#include <stdio.h>
int main()
{
	int a, b, c;
	a = 5;
	c = ++a;
	b = ++c, c++, ++a, a++;
	b += a++ + c;
	printf("a = %d b = %d c = %d\n:", a, b, c);
	return 0;
}
```
结果是
a = 9 b= 23 c = 8

```c
//代码1
int a = 1;
int b = 2;
int c = (a>b, a=b+10, a, b=a+1);//逗号表达式
c是多少？


//代码2
if (a =b + 1, c=a / 2, d > 0)

//代码3
a = get_val();
count_val(a);
while (a > 0)
{
    //业务处理
    //...
    a = get_val();
    count_val(a);
}

如果使⽤逗号表达式，改写：
while (a = get_val(), count_val(a), a>0)
{
    //业务处理
}
```

#### 10.下标访问操作符`[]`
`arr[3]`中的[]就是下标引用操作符  
`arr`和`3`就是`[]`的操作数  

**操作数：⼀个数组名 + ⼀个索引值(下标)**

```c
int arr[10] = {1,2,3,4,5,6,7,8,9,10};
//创建数组的时候,[]中不能是变量
int n = 3;
arr[n] = 20;//访问元素时,[]中可以是变量
```

#### 11.函数调用操作符`()`
接受⼀个或者多个操作数：第⼀个操作数是函数名，剩余的操作数就是传递给函数的参数。
```c
int Add(int x,int y) 
{
    return x+y;
}
int main()
{
    int sum =Add(2,3);//()就是函数调用操作符
    //Add,2,3都是()的操作数
    return 0;
}
```

#### 12.结构成员访问操作符

##### 什么是结构体
C语⾔已经提供了内置类型，如：char、short、int、long、float、double等，但是只有这些内置类型还是不够的，假设我想描述学⽣，描述⼀本书，这时单⼀的内置类型是不⾏的。描述⼀个学⽣需要名字、年龄、学号、⾝⾼、体重等；描述⼀本书需要作者、出版社、定价等。C语⾔为了解决这个问题，增加了**结构体**这种⾃定义的数据类型，让程序员可以⾃⼰创造适合的类型。


 **结构是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量，如：标量、数组、指针，甚⾄是其他结构体。**

###### 结构的声明
```c
struct tag
{
    member-list;
}variable-list;
```

```c
描述一个学生：
struct Stu
{
    char name[20];//名字
    int age;//年龄
    char sex[5];//性别
    char id[20];//学号
}; //分号不能丢
```

###### 结构体变量的定义和初始化
```c
//代码1：变量的定义
struct Point
{
    int x;
    int y;
}p1; //声明类型的同时定义变量p1

struct Point p2; //定义结构体变量p2

//代码2:初始化。
struct Point p3 = {10, 20};
struct Stu //类型声明
{
    char name[15];//名字
    int age; //年龄
};
struct Stu s1 = {"zhangsan", 20};//初始化
struct Stu s2 = {.age=20, .name="lisi"};//指定顺序初始化

//代码3
struct Node
{
    int data;
    struct Point p;
    struct Node* next; 
}n1 = {10, {4,5}, NULL}; //结构体嵌套初始化
struct Node n2 = {20, {5, 6}, NULL};//结构体嵌套初始化

```

##### 结构成员访问操作符

###### 结构体成员的直接访问
结构体成员的直接访问是通过点操作符（.）访问的。点操作符接受两个操作数。如下所⽰：
```c
#include <stdio.h>
struct Point
{
    int x;
    int y;
}p = {1,2};

int main()
{
    printf("x: %d y: %d\n", p.x, p.y);
    return 0;
}
```
**使⽤⽅式**：结构体变量.成员名

###### 结构体成员的间接访问
有时候我们得到的不是⼀个结构体变量，⽽是得到了⼀个指向结构体的指针。如下所⽰：
```c
#include <stdio.h>
struct Point
{
    int x;
    int y;
};
int main()
{
    struct Point p = {3, 4};
    struct Point *ptr = &p;
    ptr->x = 10;
    ptr->y = 20;
    printf("x = %d y = %d\n", ptr->x, ptr->y);
    return 0;
}
```
**使⽤⽅式**：结构体指针->成员名


```c
#include <stdio.h>
#include <string.h>
struct Stu
{
    char name[15];//名字
    int age; //年龄
};
void print_stu(struct Stu s)
{
    printf("%s %d\n", s.name, s.age);
}
void set_stu(struct Stu* ps)
{
    strcpy(ps->name, "李四");
    ps->age = 28;
}
int main()
{
    struct Stu s = { "张三", 20 };
    print_stu(s);
    set_stu(&s);
    print_stu(s);
    return 0;
}
```



## C++中的引用

### 一、引用的概念
引用不是新定义一个变量，而是给已存在的变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量**共用同一块内存空间。**

>类型 & 引用变量名 (对象名)（另取的别名） = 引用实体

注意： 引用类型必须和引用实体是同种类型的！


### 二、引用特性
1. 引用在定义时必须初始化
2. 一个变量可以有多个引用
3. 引用一旦引用一个实体，再不能引用其他实体(不能更改)
```cpp
void TestRef()
{
   int a = 10;
   // int& ra; // 该条语句编译时会出错
   int& ra = a;
   int& rra = a;
   printf("%p %p %p\n", &a, &ra, &rra); 
}
```

### 三、常引用
加了 const 该变量是不能修改的，即成了一种常量，可以理解为只读型，而没加 const 的可理解为可读可写型。


1.权限的平移 --- 两者都是可读可写型
```cpp
int a = 10;
int & b = a;
```

2.权限放大：
```cpp
//只读型(const)
const int a = 20;
 
//可读可写型  报错！
int &b= a;      × × ×
 
//权限平移
const int &c = a;   √ √ √ 
```

3.权限缩小：
```cpp 
//可读可写型
int e = 30;

//只读型
const int &f = e;     √ √ √
```


**! 临时变量具有常属性 !**  
类型转换，并不会改变变量类型，中间都会产生一个临时变量！！

```cpp
//临时变量具有常属性 --- 相当于被const修饰了
int ii = 1;
//发生 -- 隐式转换 -- 
double dd = ii;        //隐式类型转换是语法允许的
 
--------------------------
 
//报错   权限被放大
double &rdd = ii;      // × × × 权限被放大了
//权限的平移
const double &rdd = ii;
```

























## C++函数的参数传递
参数是调用函数与被调用函数之间交换的通道，函数定义的首部的参数称为形式参数（简称形参），调用函数时使用的参数称为实际参数（简称实参）。

### 一、传值参数

简介：在值传递机制中，作为实参的表达式的值被复制到由对应的形参名所标识的对象中，成为形参的初值。完成参数值传递之后，函数体中的语句对形参的访问、修改都是在这个标识对象上操作的，与实参对象无关。

1）第一种格式，是在一开始就声明函数体，并赋予形参整形变量x,y，并在函数体里面对形参进行所需的运算，最后才写主函数，主函数中设置好实参a,b的值，再调用函数count将实参传回去计算。
```cpp
#include<iostream>
using namespace std;
void count(int x,int y)
{
	x=x*2;
	y=y*y;
	cout<<"x="<<x<<'\t';
	cout<<"y="<<y<<endl;
}
int main()
{
	int a=3,b=4;
	count(a,b);
	cout<<"a="<<a<<'\t';
	cout<<"y="<<b<<endl;
}
```

2）第二种格式，是先写主函数，再写函数体。注意：这个时候会出现报错。为什么会报错？因为主函数找不到你所调用的函数在哪里。解决办法是：**在主函数之前声明该函数即可。**
```cpp
#include<iostream>
using namespace std;
void count(int x,int y);//函数声明
int main()
{
	int a=3,b=4;
	count(a,b);
	cout<<"a="<<a<<'\t';
	cout<<"y="<<b<<endl;
}
void count(int x,int y)
{
	x=x*2;
	y=y*y;
	cout<<"x="<<x<<'\t';
	cout<<"y="<<y<<endl;
}

```

### 二、指针参数
简介：当函数定义中的形参被说明为**指针类型**时，称为**指针参数**。形参指针对应的实参是地址表达式。调用函数时，实参把对象的地址赋给形参名标识的指针变量，被调用的函数可以在函数体内通过形参指针来间接访问实参地址所指的对象。这种参数传递方式称为指针传递或地址调用。

1）下面的例子中，x和y分别获取了a和b的地址，然后再通过swap函数进行交换。
```cpp
#include<iostream>
using namespace std;
void swap(int *x,int *y)
{
	int temp=*x;
	*x=*y;
	*y=temp;
}
int main()
{
	int a=3,b=8;
	cout<<"before swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
	swap(&a,&b);
	cout<<"after swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
}
```

2）如果我们不要指针那还会不会实现上面的交换功能呢？

```cpp
#include<iostream>
using namespace std;
void swap(int x,int y)
{
	int temp;
	temp=x;
	x=y;
	y=temp;
}

int main()
{
	int a=3,b=8;
	cout<<"before swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
	swap(a,b);
	cout<<"after swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
}
```
无法实现功能

### 三、引用参数
简介：形参被定义为引用类型时被称为引用参数。引用参数对应的实参应该是对象名。函数被调用时，形参不需要开辟新的储存空间，形参名作为引用（别名）绑定于实参标识的对象上，执行函数体时，对形参的操作就是对实参对象的操作，直至函数执行结束，撤销引用绑定。

+ 声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。
+ 一旦一个引用被初始化后，就不能改为指向其他对象。

```cpp
#include<iostream>
using namespace std;
void swap(int &,int &);
int main()
{
	int a=3,b=8;
	cout<<"before swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
	swap(a,b);
	cout<<"after swaping.....\n";
	cout<<"a="<<a<<",b="<<b<<endl;
}
void swap(int &x,int &y)
{
	int temp=x;
	x=y;
	y=temp;
}

```
这里类似像取别名了，就是 int &x=a; int &y=b。

### 四、使用const引用参数
```cpp
#include<iostream>
using namespace std;

void display(const int& rk) //定义const引用参数
{
	cout<<rk<<":\n"<<"dec:"<<rk<<endl<<"oct:"<<oct<<rk<<endl
		<<"hex:"<<hex<<rk<<endl;
}

int main()
{
	int m=2618;
	display(m);  //实参是变量
	display(4589);  //实参是常数
}

```
在本例main函数中第二次调用display函数时，用常数4589作为实参。C++规定，**函数的const引用参数允许对应的实参为常数或者表达式。**调用函数进行参数传递时将产生一个匿名对象保存实参的值。形参标识名作为这个匿名对象的引用，对匿名对象进行操作。匿名对象在被调用函数运行结束后撤销。


const引用参数的匿名对象测试
```cpp
#include<iostream>
using namespace std;
void anonym (const int &ref)
{
	cout<<"The address of val is:"<<&ref<<endl;
}
int main()
{
	int val=10;
	cout<<"The address of val is:"<<&val<<endl;
	anonym(val);
	anonym(val+5);
}
```
main函数第一次调用anonym函数时，实参是变量名。形参ref与实参val绑定。在程序输出的第1行和第2行，实参和形参的地址相同，说明引用参数与实参对象都是同一个储存单元，引用参数以别名方式在实参对象上进行操作。无论形参是否被约束，情形都一样。第2次调用anonym函数时，实参是表达式。（注意：C++为const引用建立匿名对象用于存放val+5的值。第3行输出是匿名对象的地址。**只有const引用对应的实参可以是常量或表达式，非约束的引用参数对应的实参必须是对象名。**）


## C++内联函数

### 一、认识内联函数
函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。

一个 C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。

**函数调用是有时间和空间开销的。**程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。

如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，**即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。**这种在函数调用处直接嵌入函数体的函数称为**内联函数（Inline Function），又称内嵌函数或者内置函数。**

```cpp
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
 
int main()
{
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
 
    return 0;
}

//运行结果：
//45 99
//45, 99
//99, 45
```

**注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。**


当编译器遇到函数调用swap(&m, &n)时，会用 swap() 函数的代码替换swap(&m, &n)，同时用实参代替形参，以下为替换后的结果：
```cpp
int temp;
temp = *(&m);
*(&m) = *(&n);
*(&n) = temp;
```
编译器可能会将 *(&m)、*(&n) 分别优化为 m、n。

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。下面的例子写法是不被推荐的：

```cpp
#include <iostream>
using namespace std;
 
//声明内联函数
void swap1(int *a, int *b); //也可以添加inline，但编译器会忽略
 
int main()
{
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap1(&m, &n);
    cout<<m<<", "<<n<<endl;
 
    return 0;
}
 
//定义内联函数
inline void swap1(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```
使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

对函数作 **inline 声明只是程序员对编译器提出的一个建议**，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。

### 二、内联函数和宏定义
使用宏代码最大的缺点是容易出错，预处理在拷贝宏代码时常常产生意向不到的边际效应。
例如：
```cpp
#define MAX(a,b) (a)>(b)?(a):(b)
```
语句:
```cpp
result = MAX(i,j)+2;
//被预处理器扩展为 
result = (i)>(j)?(i):(j)+2;
```
由于运算符"+"比运算符"?:"的优先级高，所以上述语句并不等价于
```cpp
result = ((i)>(j)?(i):(j))+2;
```
如果把宏代码改写为：
```cpp
#define MAX(a,b) ((a)>(b)?(a):(b))
```
则能解决优先级的问题。但是会引发另一个问题
```cpp
result = MAX(i++,j);
//被预处理器扩展为 
result = (i++)>(j)?(i++):(j) //在同一个表达式中i被两次求值。
```
宏的另一个缺点是不可调试。

**内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作的类的数据成员，所以应该尽量使用内联函数来取代宏代码。**


### 三、何时使用内联函数
内联能提高函数的执行效率，那么为什么不把所有的函数都定义成内联函数呢？
内联不是万灵丹，它以代码膨胀（拷贝）为代价，仅仅省区了函数调用的开销，从而提高程序的执行效率。（**开销指的是参数的压栈、跳转、退栈和返回操作**）。

一方面，如果执行函数体内代码的时间比函数调用的开销大得多，那么inline效率收益会很小。另一方面，每一处内联函数的调用都要拷贝代码，使程序的总代码量增大，消耗更多的内存空间。

以下情况不宜使用内联：

+ 如果函数体内代码比较长，使用内联将导致可执行代码膨胀过大。
+ 如果函数体内出现循环或者其他复杂的控制结构，那么执行函数体内代码的时间将比函数调用的开销大得多。


### 四.注意事项

+ 内联函数体内不能有循环语句和switch语句。
+ 内联函数的声明必须出现在内联函数第一次被调用之前。
+ 对内联函数不能进行异常接口声明



### 五.类的内联成员函数
1. 内联函数体中不要有复杂结构（如循环语句和switch语句）。2 .在类中声明内联成员函数的方式：
3. 将函数体放在类的声明中（隐式声明）。
4. 使用inline关键字（显式声明）。

























## C++默认形参问题

### 一、带默认形参值的函数
函数在定义时可以预先给出默认的形参值。  
调用时：
1. 如给出实参，则采用实参值，
2. 否则采用预先给出的默认形参值。
```cpp
int add(int x=5,int y=6)
{    
    return  x+y;
}
void main(void)
{    
    add(10,20); //10+20
    add(10);  //10+6   
    add();   ////5+6
}
```

### 二、默认形参值的说明次序
默认形参值必须从右向左顺序声明，并且在默认形参值的右面不能有非默认形参值的参数。
```cpp
int add(int x,int y=5,int z=6); 
int add(int x=1,int y=5, int z); //错误的
int add(int x=1, int y, int z=6); //错误的
```

### 三、默认形参值的作用域
在相同的作用域内，默认形参值的说明应保持唯一，但如果在不同的作用域内，允许说明不同的默认形参。
```cpp
int add(int x=1,int y=2);
int main()
{  
    int add(int x=3,int y=4);
    add(); //使用局部默认形参值（实现3+4）
    return 0;
}
void fun(void)
{   ...
     add();//使用全局默认形参值（实现1+2）
}
```





## C++构造函数的各种用法全面解析
```
A (A& a);						//拷贝构造函数
A (const A& a);					//拷贝构造函数
A& operator= (const A& a);		//赋值构造函数
```
### 一、构造函数的基本用法

#### 1、构造函数概念
一个类的对象被创建的时候，编译系统为对象分配内存空间，并**自动调用该构造函数,由构造函数完成成员的初始化工作**。因此，构造函数的核心作用就是，**初始化对象的数据成员**。


#### 2、构造函数的特点
1. **名字与类名相同**，可以有参数，但是不能有返回值（连void也不行）。  
2. **构造函数是在实例化对象时自动执行的，不需要手动调用。**  
3. 作用是对对象进行初始化工作，如给成员变量赋值等。  
4. 如果定义类时没有写构造函数，系统会生成一个默认的无参构造函数，默认构造函数没有参数，不做任何工作。  
5. 如果定义了构造函数，系统不再生成默认的无参构造函数.  
6. 对象生成时构造函数自动调用，**对象一旦生成，不能在其上再次执行构造函数**，一个类可以有多个构造函数，为**重载**关系。
7. 构造函数中，变量初始化的顺序，是以变量定义的顺序来定的，而不是简单的以构造函数中变量出现的顺序来定的

#### 3、构造函数的分类

+ **按参数种类分为**：无参构造函数、有参构造函数、有默认参构造函数。
+ **按类型分为**：普通构造函数、拷贝构造函数(赋值构造函数)。

#### 4、在类内定义构造函数（基本用法）
```cpp
#include <iostream>
using namespace std;

//声明Time类 
class Time
{
public:  //成员函数共有部分 
	Time()  //定义构造成员函数，函数名与类名相同 
	{
		hour= 0;//利用构造函数给对象中的数据成员都赋初值为0 
		minute= 0;
		sec= 0;
	}
	//成员函数的声明
	void set_time(); 
	void show_time(void);
private:  //类的私有数据部分 
	int hour;  //默认数据也是私有的 
	int minute;
	int sec; 
};

//定义成员函数
//获取时间数据函数 
void Time::set_time(void)  
{
	cin >> hour;
	cin >> minute;
	cin >> sec;
}

//显示时间格式的函数 
void Time::show_time(void)  //显示时间函数 
{
	cout << hour << ":" << minute << ":" << sec << endl;
}

//主函数 
int main()
{
	Time t1;  //通过类Time实例化对象t1
	t1.set_time();  //调用成员函数，给t1的数据成员赋值
	t1.show_time();  //显示t1的数据成员值 
	return 0;
}
```

### 二、带参构造函数与其调用

#### 1、带参构造函数
简单来说，就是构造函数定义中带有参数，然后对参数进行操作；

**调用构造函数内==实例化对象**；

在调用时，传入参数。和无参数的构造函数的调用做个对比就很清晰了：
```c
//假设已经定义了一个类Box，则在实例化对象时，也就是调用构造函数时：
Box b1;  //实例化无参构造函数
Box b2(10001, "Chung", 'F');  //实例化带参构造涵数，传入指定的参数
//提示：正常情况下没有定义构造函数的话，就会默认生成一个构造函数，不影响数据的赋值，也不需要调用
```

#### 2、有参构造 实例
```cpp
#include <iostream>
using namespace std;

class Box
{
public:
	Box(int, int, int);  //声明带参数的构造函数
	int Volume();  //声明计算体积的构造函数
private:  //私有数据部分定义长宽高的变量 
	int height;
	int width;
	int length; 
};

//定义Box类的构造函数 ，带有3个参数 
Box::Box(int h, int w, int len) 
{
	height= h;  //对私有成员进行初始化 
	width= w;
	length= len;  
}
//也可以简化写成一行：Box(int h, int w, int len):height(h), width(w), length(len){  } 

//定义计算体积的成员函数
Box::Volume() 
{
	return(height * width * length);  //计算体积 
}

//定义主函数 
int main()
{
	//由于构造函数是带有参数的，因此实例化时需要传入参数 
	Box b1(12, 25, 30);  //通过Box类实例化对象b1 
	cout << "盒子1的体积为：" << b1.Volume() << endl;
	Box b2(15, 30, 21);  //实例化对象b2
	cout << "盒子2的体积为：" << b2.Volume() << endl;
	return 0; 
}
```

#### 3、初始化列表
在定义带参构造函数时，可以两种写法，都可以进行传参。
（1）正常写法
```cpp
//加入已经定义了类Box，则构造函数的定义如下：
Box(int h, int w, int len) 
{
	height= h;  //对私有成员进行初始化 
	width= w;
	length= len;  
}
```
(2)初始化列表写法
```cpp
Box(int h, int w, int len):height(h), width(w), length(len){  } 
```
这种写法是需要直接定义参数变量再对成员变量赋值的，而是写成了一行，

注意点：变量必须一一对应才能正常传参。

#### 4、有默认参数的构造函数

就是带有默认参数的构造函数，在实例化时若传入参数，则传入的参数值优先；若没有传入参数，则就使用指定的默认参数。

```cpp
#include <iostream>
using namespace std;

class Box
{
public:
	Box(int h=10, int w=10, int len=10);  //声明带参数的构造函数
	int Volume();  //声明计算体积的构造函数
private:  //私有数据部分定义长宽高的变量 
	int height;
	int width;
	int length; 
};

//定义Box类的构造函数 ，带有3个参数 
Box::Box(int h, int w, int len) 
{
	height= h;  //对私有成员进行初始化 
	width= w;
	length= len;  
}
//也可以不指定默认参数： Box::Box(int h, int w, int len){  }

//定义计算体积的成员wa函数
Box::Volume() 
{
	return(height * width * length);  //计算体积 
}

//定义主函数 
int main()
{
	//由于构造函数是带有默认参数的，因此实例化时可以不传入参数 
	Box b1;  //通过Box类实例化对象b1 
	cout << "盒子1的体积为：" <<  b1.Volume() << endl;
	//传入不同个数参数的对象 
	Box b2(1);  //实例化对象b2，传入一个参数 ，默认对应第一个参数，即int h=1 
	cout << "盒子2的体积为：" << b2.Volume() << endl;
	Box b3(1, 1);  //通过Box类实例化对象b3 ，h=1, w=1 
	cout << "盒子3的体积为：" <<  b3.Volume() << endl;
	Box b4(1, 1, 1);  //实例化对象b4， h=1, w=1, len=1 
	cout << "盒子4的体积为：" << b4.Volume() << endl;
	return 0; 
}
```

### 三、拷贝构造函数

#### 1、概念

+ 一种特殊的构造函数，**当对象之间复制时会**自动调用拷贝构造函数.
+ 若类中没有显示定义拷贝构造函数，则系统会自动生成默认拷贝构造函数.
+ 使用场合：旧对象初始化新对象.
+ 拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类型的引用。当定义一个新对象并用同一类型的对象都它进行初始化时，将显示使用拷贝构造函数，当该类型的对象传递给函数返回该类型的对象时，将隐式调用拷贝构造函数.
+ 当类中有一个数据成员是指针时，或者有成员表示在构造函数中分配的其他资源，必须显示定义拷贝构造函数.

**构造函数的使用情况:**
1. 一个对象以值传递的方式传入函数体.
2. 一个对象以值传递的方式从函数体返回.
3. 一个对象需要通过另一个对象进行初始化.

```cpp
#include <iostream>
using namespace std;

class Test
{
public:
    // 构造函数
    Test(int a):t_a(a){cout<<"creat: "<<t_a<<endl;}
    // 拷贝构造函数
    Test(const Test& T)
    {
        t_a = T.t_a;
        cout<<"copy"<<endl;
    }
    // 析构函数
    ~Test()
    {
        cout<<"delete: "<<t_a<<endl;
    }
    // 显示函数
    void show()
    {
        cout<<t_a<<endl; 
    }
private:
    int t_a;
};

// 全局函数，传入的是对象
void fun(Test C)
{
    cout<<"test"<<endl;
}

int main()
{
    Test t(1);
    // 函数中传入对象
    fun(t);
    return 0;
}


```
#### 2、自定义拷贝构造函数
如果自定义了拷贝构造函数，则系统不会默认生成拷贝构造函数了。自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。

```cpp 
//假如已经定义了一个类Box，则通过以下方式定义拷贝构造函数：
Box(const Box &p)  
{
	age= p.age;
	name= p.name;
}

//调用拷贝构造函数
Box b3(b2);  //传入参数就是一个对象b2
```
在定义拷贝函数那个括号中：p是一个引用类型，括号内相当于Box p=b2，b2是已经实例化的一个对象，const加上&就是常量引用了。

因此，**拷贝构造就是简单的拷贝值，因为它就是个常量引用，**此处就是引用了对象b2。调用那句，就是说明通过Box类实例化一个对象b3，引用了对象b2的数据。

#### 3、匿名对象（少用）

简单来说，就是没有名字的对象，这个对象只能用一次，只在定义行起作用，一般情况是不会去用它的。
```cpp
//假如已经定义好了类Box，则可以有以下三种匿名对象的实例化：
Box (10, "Chung");  //有参构造函数匿名对象
Box ();  //无参构造函数匿名对象

//有名对象调用（用以区别匿名对象）
Box p(15, "Hawk");

```
**注意**：匿名对象不能用括号法调用拷贝函数，也就是说不能写成这样：Box (b2);


#### 4、显示法调用构造函数（实例化）
```cpp
//假如已经定义好了类Box，则实例化对象时可以用显示法：
Box b1= Box(10, "Chung");  //调用有参构造函数
Box b2= Box();  //调用无参构造函数
Box b3= Box(b1);  //调用拷贝函数
```

#### 5、隐式法调用构造函数（实例化）
```c
//假如已经定义好了类Box，则调用使用隐式法实例化对象为以下三种情况：
Box b1= {10, "Chung"};  //调用有参构造函数
Box b2= b1;  //调用拷贝函数

//注意：隐式法无法调用无参构造函数，也就是不能写成：
Box b3={};
```
禁止隐式法调用构造函数可在构造函数定义前加上：`explicit`


### 四、构造函数的重载
与普通的函数重载基本是没有区别，就是同一个函数名因为参数不同代表不同的函数，只是这里的构造函数都没有返回值：

```c
#include <iostream>
using namespace std;

//声明一个Box类 
class Box
{
public:
	Box();  //声明一个无参数的构造函数（并未定义） 
	//定义一个有参数的构造函数，用参数的初始化表对数据成员初始化 
	Box(int h, int w, int len):height(h), width(w), length(len){  }  
	//相当于：
	/*Box(int h, int w, int len)
	{
		h= height;
		w= width;
		length= len;
	} */
	int Volume();  //声明成员函数V，也就是计算体积的函数 
private:  //私有部分，数据成员的定义 
	int height;
	int width;
	int length;
};

//在类外面定义无参数的构造函数Box 
Box::Box()
{
	height= 10;  //在构造函数里对类的私有成员进行私有化
	width= 10;
	length= 10; 
}

//在类外定义进行有长、宽、高计算的成员函数
int Box::Box::Volume()
{
	return (height * width * length);
} 

int main()
{
	Box b1;  //通过Box类实例化对象b1 
	cout << "通过无参构造函数初始化的盒子体积为：" <<  b1.Volume() << endl;
	Box b2;  //实例化对象b2
	cout << "通过有参构造函数初始化的盒子体积为：" << b2.Volume() << endl;
	return 0; 
}
```


### 五.构造函数例子

#### 1.例子一
```cpp
#include <iostream>
using namespace std;

class Coordinate
{
public:
    // 无参构造函数
    // 如果创建一个类你没有写任何构造函数，则系统自动生成默认的构造函数，函数为空，什么都不干
    // 如果自己显示定义了一个构造函数，则不会调用系统的构造函数
    Coordinate()
    {
        c_x = 0;
        c_y = 0;
    }     

    // 一般构造函数
    Coordinate(double x, double y):c_x(x), c_y(y){}   //列表初始化
    // 一般构造函数可以有多个，创建对象时根据传入的参数不同调用不同的构造函数

    Coordinate(const Coordinate& c)
    {
        // 复制对象c中的数据成员
        c_x = c.c_x;
        c_y = c.c_y;
    }

    // 等号运算符重载
    Coordinate& operator= (const Coordinate& rhs)
    {
        // 首先检测等号右边的是否就是等号左边的对象本身，如果是，直接返回即可
        if(this == &rhs)
            return* this;
        // 复制等号右边的成员到左边的对象中
        this->c_x = rhs.c_x;
        this->c_y = rhs.c_y;
        return* this;
    }
    double get_x()
    {
        return c_x;
    }
    double get_y()
    {
        return c_y;
    }

private:
    double c_x;
    double c_y;
};

int main()
{
    // 调用无参构造函数，c1 = 0，c2 = 0
    Coordinate c1, c2;
    // 调用一般构造函数，调用显示定义构造函数
    Coordinate c3(1.0, 2.0);
    c1 = c3;    //将c3的值赋值给c1，调用"="重载
    Coordinate c5(c2);
    Coordinate c4 = c2;    // 调用浅拷贝函数，参数为c2
    cout<<"c1 = "<<"("<<c1.get_x()<<", "<<c1.get_y()<<")"<<endl
        <<"c2 = "<<"("<<c2.get_x()<<", "<<c2.get_y()<<")"<<endl
        <<"c3 = "<<"("<<c3.get_x()<<", "<<c3.get_y()<<")"<<endl
        <<"c4 = "<<"("<<c4.get_x()<<", "<<c4.get_y()<<")"<<endl
        <<"c5 = "<<"("<<c5.get_x()<<", "<<c5.get_y()<<")"<<endl;
    return 0;
}
```
```
c1 = (1, 2)
c2 = (0, 0)
c3 = (1, 2)
c4 = (0, 0)
c5 = (0, 0)
请按任意键继续. . .
```

## 命名空间-namespace

### 一.为什么需要命名空间
命名空间是ANSI C++引入的可以由用户命名的作用域，用来处理程序中常见的同名冲突。
在c++中有4层次的作用域：**文件、函数、类、复合语句**。在不同的作用域中可以定义名字相同的变量，互不干扰，便于系统区别他们。  
如下：
```cpp
class A
{
public:
    void fun1();
private:
    int i;
};

void A::fun1()
{

}

class B
{
public:
    void fun1();
private:
    int i;
};

void B::fun1()
{

}
```
这样，他们就不会发生混淆。  

但是，一个大型的应用软件，往往不是由一个人独立完成的，而是由若干不同的人合作完成的，不同的人分别完成不同的部分，最后组成一个完整的程序。假如不同的人分别定义了类，放在了不同的文件中，在主函数的文件中需要使用这些类时，就用#include指令将这些头文件包含进来。由于头文件是由不同的人设计的，有可能在不同头文件中用了相同的名字来命名所定义的类或函数。这样，程序中就会出现名字冲突。  

以下面的程序为例，在People A.h和People B.h分别定义类和函数：
```cpp
//PeopleA.h
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    string name;
    char sex;
};
int fun(int a, int b)
{
    return a + b;
}

//PeopleB.h
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    char sex;
    string name;
};
int fun(int a, int b)
{
    return a + b;
}
```
假如在主程序中要用到People A.h中的Student函数，需要在头文件中包含People A.h，同时要用到People B.h中的Student函数，需要在头文件中包含People B.h，如果主程序如下：
```cpp
#include <iostream>
#include "People A.h"
#include "People B.h"
int main()
{
    Student stdu1(101, 18, "wang");
    cout << fun(5, 3) << endl;
    return 0;
}
```
这时程序就会出错，因为在预编译后，头文件中的 内容取代了对应的#include指令，这样就在同一个程序文件中出现了两个Student类和两个fun函数，显然是重复定义，这就是名字冲突，即在同一个作用域中有两个或者多个同名的实体。


### 二.什么是命名空间
所谓命名空间，实际上就是一个由程序设计者命名的内存区域。程序设计者可以根据需要制定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。如：
```cpp
namespace AA
{
    int a;
    double b;
}
```
namespace是定义命名空间锁必须写的关键字，AA是自己制定的命名空间的名字。如果在程序中要使用a和b，必须加上命名空间名和作用域分辨符`::`，如`AA::a`，`AA::b`，这种用法称为命名空间限定。

命名空间的作用是建立一些互相分隔的作用域，把一些全局实体分隔开来，以免产生名字冲突。


### 三.使用命名空间解决名字冲突
如下程序为例：
```cpp
//PeopleA.h
namespace PeopleA
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    string name;
    char sex;
};
int fun(int a, int b)
{
    return a + b;
}

//PeopleB.h
namespace PeopleB
class Student
{
public:
    Student(int n, char s, string name)
    {
        //.....
    }
private:
    int num;
    char sex;
    string name;
};
int fun(int a, int b)
{
    return a + b;
}

#include <iostream>
#include "People A.h"
#include "People B.h"
int main()
{
    PeopleA::Student stdu1(101, 18, "wang");
    cout << PeopleA::fun(5, 3) << endl;
    PeopleB::Student stdu1(101, 18, "wang");
    cout << PeopleB::fun(5, 3) << endl;
    return 0;
}
```

### 四.使用命名空间成员的方法
在引用命名空间成员时，要用命名空间名和作用域分辨符对命名空间成员进行限定，以区别不同的命名空间中的同名标识符。

即：命名空间名::命名空间成员名  

c++提供了一些机制，能简化使用命名空间的使用：
1. 使用命名空间别名
```
可以为命名空间起一个别名，用来替代较长的命名空间名，如：
namespace PeopleA
可以用一个较短的别名替代它。如：
namespace PA = PeopleA
```
2. 使用using命名空间成员名
```
using后面的命名空间成员名必须是由命名空间限定的名字，如：
using AA::i；
```
3. 使用using namespace命名空间名
```
如：using namespace AA;
声明了在本作用域中要用到命名空间AA中的成员，在使用该命名空间的任何成员时都不必再使用命名空间限定。
```

### 五.无名的命名空间
c++中可以声明无名的命名空间，如：

```
namespace 
{
    void fun()
    {
        //....
    }
}
```

由于命名空间没有名字，在其他文件中显然无法引用，它只在本文件的作用域有效。若无名命名空间的成员fun函数的作用域为文件A，在文件A中使用无名命名空间的成员，不用也无法用命名空间名限定。

### 六.标准命名空间std

标准C++库中的所有标识符都是在一个名为std的命名空间中定义的，或者说标准头文件中的函数、类、对象和模板实在命名空间std中定义的。一般用using namespace语句对命名空间std进行声明，这样可以不必对每个命名空间成员一一进行处理，在文件的开头加入如下语句：  
```cpp
using namespace std;
```
这样，在std中定义和声明的所有标识符在本文件中都可以作为全局变量来使用。


### 总结
由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：

1. 直接指定标识符。例如std::ostream而不是ostream。  
完整语句如下  
```cpp
std::cout << std::hex << 3.4 << std::endl;
```
2. 使用using关键字。
```cpp
using std::cout;
using std::endl;
//以上程序可以写成
cout << std::hex << 3.4 << endl;
```
3. 最方便的就是使用using namespace std;
```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;
cout << hex << 3.4 << endl;
```

## 作用域与可见性


### 一.总概述
在所有的计算机程序中，一个基本的目标是操作一些数据，然后获得一些结果。为了操作这些数据，需要为这些数据分配一段内存，我们可以将这段内存称为变量。为了方便操作，以及程序可读性方面的考虑，需要使用一个有意义的名称来引用这段内存，这个名称就是变量名。

将名称和一段内存关联起来的工作可以分成两个阶段来进行，分别是变量的声明和定义。在变量声明的时候，只是引入了一个名称，该名称并没有和一段特定的内存关联。也就是说，在声明变量的时候，只是引入了一个助记符，并没有执行内存分配。在定义变量的时候，将前面声明过程中引入的名称关联到了一段特定的内存，内存的大小由变量的类型决定。也就是说，在定义变量的时候，真正执行了内存分配。在有的情况下，变量的声明和定义是需要分开进行的，如：全局变量的声明和定义，可以在多个文件中使用该变量；而在某些情况下，使用一个语句就可以完成变量的声明和定义，如：局部变量的声明和定义。只需要在一个文件中使用该变量。

在C++程序中，当声明并定义了一个变量以后，需要关注如下两个问题：
1. 由声明引入的变量名可以用在什么地方，如何进行名字解析；
2. 由定义分配的内存的生命周期是多少。

为了解决这两个问题，就需要引入**作用域**的概念。作用域是C++程序中的一段区域，一般用正反两个花括号来界定它的范围。**在同一个作用域范围内，一个名称只能唯一关联到一个实体，这个实体可以是变量，函数，类型，模版等。**也就是说，在同一作用域范围内，不同的实体必须对应不同的名称，绝对不允许出现两个不同的实体对应同一个相同的名称的情况。一个名称可以和不同作用域中的不同实体相对应。也就是说，对于同一个名称，在不同的作用域中可以重复使用。

在本文的后续部分，将对各种类型的作用域进行描述，并且介绍在作用域中进行名字解析的规则。

### 二.作用域的分类


#### 1.概述
我们可以将整个C++程序（在程序中包括各种类型，函数，模版，变量等，并且分布在很多个*.cpp文件中）看成一个很大的整体区域。为了方便对C++程序中已经定义的各种类型，函数，模版，变量的管理，可以把这片大的区域划分成一片片小的命名区段。然后根据各个类型，函数，模版，变量的功能以及用途等，再把这些类型，函数，模版，变量等分别放置在不同的区段中。这些小的区段叫做作用域，C++程序支持四种形式的作用域，分别是：**名字空间作用域，类域，局部作用域，语句作用域。**

名字空间作用域就是程序员利用名字空间定义在C++程序中划分出来的一块比较大的程序区段。在该程序区段内部，可以定义类型，函数，模版，变量。名字空间作用域可以跨越多个*.cpp文件而存在。在名字空间作用域内部还可以继续定义其他的名字空间作用域，也就是说，**名字空间作用域是可以互相嵌套的。**

全局作用域是C++程序最外层的名字空间作用域，也是最大的名字空间作用域。**全局作用域天然存在于C++程序中，它不需要由程序员人为地定义。在全局作用域内部，可以包含其他的，由程序员定义的名字空间作用域，以及没有包含在其他名字空间作用域中的类型，函数，模版，变量。**在全局作用域中定义的变量是全局变量，在全局作用域中定义的函数是全局函数。

在C++程序中，每定义一个类就会引入一个类域。类体所包含的范围就是类域的范围，在类中定义的所有成员都属于该类域。类域位于名字空间作用域内部，该名字空间作用域可能是全局作用域，也可能是用户定义的名字空间作用域。

**每一个函数体内部都是一个局部作用域。该作用域起始于函数体的左花括号“｛”，结束于函数体的右花括号“｝”。**每一个函数都有一个独立的局部作用域。在局部作用域内定义的变量都是局部变量。

在C++程序中，当要求使用单个语句，但程序逻辑却需要不止一个单个语句的时候，我们可以使用复合语句。复合语句通常被称为块，是用花括号括起来的一些单个语句的集合。在复合语句花括号内部的区段也属于局部作用域。

有些语句存在控制结构，并且允许在控制结构中定义变量。如：
```cpp
//示例一：
for ( int K = 0; K < 100;K++ )
  cout << K;     //该行语句属于语句作用域范围，K仅在这一行有效。

//示例二：
for (int K = 0; K < 100;K++)
{
   … //其他代码
   Cout << k;   //花括号内部是复合语句，都属于语句作用域。K在整个花括号内有效。
   … //其他代码
}
```
从控制语句的开始到控制语句结束这一段区域被称为语句作用域。在该控制结构中定义的变量，仅在该语句作用域内有效。如：示例二中，K在花括号内有效，或者示例一中，仅在语句“cout << K;”中有效。语句作用域是最小的作用域。

#### 2.名字空间作用域

##### 2.1名字空间的意义

使用名字空间可以在一定程度上解决命名冲突的问题。假设没有名字空间，那么在C++程序中，所有的实体，如：函数，类型，变量，模版等，都必须被放置在全局域中作为全局实体而出现。在全局域中，这些实体必须具有唯一的名称，不允许存在多个实体同名的情况。因此，当在全局域中引入一些第三方开发的类库的时候，必须要保证第三方类库中命名的实体与全局域中命名的实体在命名方面不冲突。但是，这是很难保证的。为了解决这个问题，就引入了名字空间的概念。

第三方开发方在开发类库的时候，可以首先声明一个名字空间，每一个用户声明的名称空间都代表一个不同的名字空间域。在该名字空间中，可以包含嵌套其他的名称空间，以及函数，类型，变量，模版等的声明和定义。在该名称空间内部声明的实体被称为**名称空间成员**。用户在名字空间中声明的每个实体的名字必须是唯一的，不允许重名。因为在不同用户声明的名字空间中引入了不同的域，所以在这些由不同用户声明的名字空间中可以使用相同的名称。通过这种方式解决了命名冲突的问题。

**在使用名字空间中的成员的时候，名字空间成员的名字会自动与该名字空间重合，或者说被其限定修饰。如：在名字空间A中声明的类B，它的名字是：A::B。**


##### 2.2名字空间的定义

用户声明的名字空间以namespace关键字开头，后面是名字空间的名称。名字空间的范围以花括号界定，具体的格式如下：

```cpp
namespace mySpace //mySpace是名字空间的名称
{
   Class myClass { … }; //类定义
   Int myFunction(int para1,int para2); //函数的声明
   Extern double myVar; //变量的声明
}
```
在上面的示例中，声明了一个名称为mySpace的名字空间，该名字空间的作用域由花括号界定，在花括号内部的部分都属于该名字空间的作用域。在该名字空间中，定义了一个类：myClass，声明了一个函数：myFunction，以及一个变量myVar。它们都是该名字空间的成员。

用户声明的名字空间可以位于全局作用域中，也可以位于其他的名字空间的作用域中。在当前的作用域中，名字空间的名称是唯一的，不能与其类型的实体重名。

**在同一个作用域中，可以多次声明相同名称的名字空间。**在这种情况下，将会实现名字空间的累加。比如，A.h头文件和A.cpp源文件都位于全局作用域中，在这两个文件中分别声明如下的名字空间：
```cpp
//A． h文件的代码实现：

namespace mySpace //在这里实现了函数和变量的声明，属于接口部分。

{
   Int AddData (int para1,int para2); //函数的声明

   Extern double myVar;  //变量的声明

}

//B.cpp文件的代码实现：

Include “A.h”
namespace mySpace // 在这里实现了函数和变量的定义，属于实现部分。
{
   Int AddData(int Para1,int Para2) //函数的定义
   {
      Return Para1+Para2;
   }
    Double myVar = 3.14;  //变量的定义，并初始化。
}
```
在这里，存在这样一个规则：在同一个作用域中，如果新声明的一个名字空间的名称与前面声明过的名字空间的名称同名，那么这个后声明的名字空间就是前面声明的名字空间的累加，这两部分内容属于同一个名字空间；如果新声明的这个名字空间不与当前作用域中任何名字空间同名，那么就会定义一个新的名字空间。

在上面的示例中，A.h和A.cpp文件位于全局作用域中。在全局作用域中，两次声明的名字空间具有相同的名称：mySpace。因此，认为这两次声明的名字空间属于同一个名字空间。

通过对上面所描述的规则的使用，在程序设计的时候，可以根据需要，将名字空间的声明拆分成若干个部分来实现，只要这几个部分的声明都在同一个作用域中即可。这个规则的一个典型应用就是：实现接口和具体实现的分离。

在上面的示例中，我们将函数AddData和变量myVar的声明放在了A.h头文件中，而将它们的定义放在了另外一个A.cpp的源文件中。 A.h头文件实现的是函数库的接口的，而A.cpp文件中的内容则是针对接口的实现。因此，在程序设计和开发的时候，这两部分内容可以分别由不同的人在不同的时间实现。通过这种方式，实现了接口和具体实现分离的原则。


##### 2.3名字空间成员的定义
当定义了名字空间以后，就可以想名字空间中添加成员。这些被添加的成员可以是：**类型，函数，变量，模版**等。可以通过两种方式向名字空间中添加成员。

1. 第一种方式是：在定义名字空间的同时，在名字空间的花括号内直接完成名字空间成员的定义。也就是说，无论名字空间的定义是采用累加的形式，还是该名字空间分布在多个物理文件中，名字空间成员的声明和定义都在名字空间内部进行。具体示例如下：
```cpp
//方式一：在名字空间中直接完成成员的定义。成员的定义不在划分为声明和定义两部分。
Namespace mySpace
{
   Double myVar = 3.14;
   Int myFunction(int Para1)
   {
       Return Para1*10;
   }
}

//方式二：在名字空间中先完成成员的声明，然后采用名字空间累加的方式，在其他部分完成成员的定义。这个“其他部分”，可以是其他的物理文件，也可以是同一个物理文件。

Namespace mySpace
{
    Extern double myVar;
    Int myFunction(int Para1);
}

Namespace mySpace
{
    Double myVar = 3.14;
    Int myFunction(int Para1)
    {
       Return Para1*10;
    }
}
```
在上面的代码中，在定义了名字空间的同时（无论是采用累加方式，还是一次性完成），在名字空间内部完成了函数myFunction和变量myVar的定义。名字空间的定义和名字空间成员的定义同步完成。

2. 第二种方式是：在定义名字空间的时候，仅仅在名字空间中完成对名字空间成员的声明，而名字空间成员的定义在名字空间之外被实现。具体代码如下：

```cpp
//首先在一个文件中完成名字空间的定义，以及名字空间成员的声明。一般情况下，该文件为头文件（A.h）。
Namespace mySpace
{
    Class myClass {….}；//声明一个类型
    myClass myFunction(myClass Para1);//声明一个函数，该函数返回myClass类型，并以myClass类型为参数。
}
```

在上面的代码中，完成了对名字空间mySpace的定义，同时在名字空间内部，完成了类myClass的定义，以及对函数myFunction的声明。接下来需要在其他地方，名字空间以外，完成对名字空间成员myFunction函数的定义。具体代码如下：

```cpp
//实现函数myFunction定义的位置，可以是另外一个文件，一般为cpp文件，但是也可以在原来的头文件中（一般不会这么干）。
#include “A.h”
mySpace::myClass mySpace::myFunction(myClass Para1)
{
    //下面完成函数的具体实现。
   …
}
```
在上面的代码中，我们可以看到两处差异。一处是函数的返回值类型，myClass被名字空间mySpace限定修饰了；而在函数的参数类型处，myClass直接使用，没有被名字空间mySpace限定修饰。

这里存在这样一个规则：在函数的限定修饰名称“mySpace::myFunction”之后，直到方括号结束的区域都属于mySpace名字空间的作用域范围。也就是上面代码中的红色部分。

也就是说名字空间的作用域可能会有两部分组成，在大多数情况下，名字空间的作用域是由定义名字空间的时候，名字空间体的花括号界定的。但是，当在名字空间之外定义名称空间的成员的时候，在名字空间成员的限定修饰名之后直到结束花括号`（” }”）`，或者分号（;）的部分都属于该名字空间作用域范围。

因此，在上面的代码中，参数的类型不需要被限定修饰，因为那个区域是属于名字空间作用域内的；而函数的返回类型必须要被限定修饰，因为那个区域不属于名字空间的作用域内。

另外还需要注意，在名字空间之外实现名字空间成员的定义的时候，要有一个前提，**那就是：名字空间成员的声明必须在名字空间之内实现。**


##### 2.4名字空间成员的使用

在C++程序中，使用名字空间的方式封装一些函数库或者类库的时候，一般情况下，通常的做法是这样的：**首先在一个头文件中定义一个名字空间，然后在该名字空间的定义中声明所有的名字空间成员，如：函数，类型，变量等。**之后将这个头文件引入到一个cpp文件中，并且在这个cpp文件中实现所有名字空间成员的定义。具体示例如下：
```cpp
-----------------A.h------------------------------//头文件名称
namespace myCPlusPlusFunctionsV1.0
{
     Class myClass { …//类成员的声明 }; //定义一个类型
     Extern double myVar; //声明变量
     Void DealClass(myClass*); //声明函数
}
-----------------A.cpp--------------------------//源文件

#include “A.h”

Namespace myCPlusPlusFunctionsV1.0
{
	myClass:: myClass() { … // myClass构造函数的实现}
	…
	//其他myClass类成员的定义。
	…
	double myVar = 3.14;//变量的定义
	void DealClass(myClass*pClass)
	{
  		…//函数的具体实现。
	}
}
```
在使用这些函数库或者类库的时候，首先需要将这个定义了该名字空间的头文件引入，然后开始使用该名字空间中的一些成员。在使用名字空间成员的时候，有三种方式：

1. 第一种方式：域操作符方式。通过域操作符加名字空间名称的方式对名字空间成员名进行限定修饰。具体代码如下：
```cpp


------------------otherCPlusPlusFile.cpp-------------------------

#include “A.h”
Void main()
{
   myCPlusPlusFunctionsV1.0::myClass *pClass = new myCPlusPlusFunctionsV1.0::myClass;
   myCPlusPlusFunctionsV1.01::DealClass(pClass);
}
```

在上面的代码中，“::”是域操作符。名字空间成员的声明被隐藏在名字空间之中，所以，名称空间的成员名称不会与当前作用域中的对象实体名称产生冲突。在使用名字空间成员的时候，可以使用名字空间名+域操作符+名字空间成员名称的方式将名字空间成员引入到当前的作用域中。否则，在当前作用域中，编译器不会找到名字空间的成员。

域操作符也可以被用来引用全局作用域的成员。因为全局作用域没有名称，所以使用如下的符号：
```cpp
::member_name
```

指向全局名字空间的成员。当全局名字空间成员的名称被局部作用域中的名字隐藏的时候，但又需要在局部作用域中使用全局成员的时候，就可以使用这种引用方式。

在上面的示例中，名字空间的名称“myCPlusPlusFunctionsV1.0”比较长，在使用的时候，可能会不方便，因此，C++在处理这个问题的时候，引入了**名字空间别名**的概念。


所谓**名字空间别名**就是为已经定义的名字空间取一个其他的、替代性的名称，一帮情况下，这个名称是简短的，容易记忆的。具体使用方式如下：
```cpp
 
------------------otherCPlusPlusFile.cpp-------------------------
#include “A.h”
Namespace myC++ = myCPlusPlusFunctionsV1.0;
Void main()
{
   myC++::myClass *pClass = new myC++::myClass;
   myC++::DealClass(pClass);
}
```
在上面的代码中，为名字空间“myCPlusPlusFunctionsV1.0”定义了一个别名“myC++”。之后在引用该名字空间成员的时候，就可以使用该别名。

定义名字空间别名的格式是：**以关键字namespace开头，后跟名字空间的别名，并且等于前面定义好的名字空间的名称。**

2. 第二种方式：使用using 声明，一次引入一个名字空间成员。

Using 声明的作用是：使一个名字空间成员在当前作用域中可见，可见的范围是从using声明的语句开始，直到当前作用域结束。如果在using声明语句之后，在当前作用域中又嵌套了其他的作用域，那么using声明在当前作用域中的嵌套作用域中也同样有效。

Using声明以关键字`using`开头，后跟名字空间的成员名称。该成员名称必须是名字空间名称+域操作符+名字空间成员名称形式的限定修饰名称。具体代码如下：
```cpp
//名字空间的定义
Namespace mySpace
{
	Int myFunction(int Para)//在名字空间中定义了一个函数
	{
     	Return Para*10;
	}
}
//在全局作用域中使用using声明，将名字空间成员名引入当前作用域。
Using mySpace::myFunction;
//开始使用名字空间的成员
Void main()
{
   //也可以在此位置使用using声明，即在局部作用域使用using声明。
   myFunction(10);//使用名字空间的成员。因为使用了using声明，所以不需要使用限定修饰的形式。名称myFunction从using声明开始，直到当前作用域结束。
}
```
在上面的代码中，首先定义了一个名字空间，并在名字空间中定义了一个函数。然后在全局作用域中使用了using声明。之后，在main函数中使用名字空间的成员函数myFucntin。

**可以在全局作用域，名字空间作用域，局部作用域中使用using声明。**在使用了using 声明以后，一次只能从源名字空间向当前作用域中引入一个名字空间成员，但可以多次使用using声明。如果该名字空间成员是函数，并且在该名字空间中具有多个重载，那么在使用using声明的时候，所有的重载函数都会被引入到当前的作用域中。**被引入的名字空间成员名只在当前作用域中有效，并且名称唯一。这个被引入的名字空间成员名会隐藏当前作用域外围作用域中的同名名称，也会被当前作用域的嵌套作用域中的同名名称隐藏。**具体情况见如下代码：

```cpp
namespace mySpace
{
   Int myIntVar = 10;//定义一个整型变量。名字空间成员。
}

Int myIntVar = 100;//全局变量
Int main()
{
	Using mySpace::myIntVar;//该using声明隐藏了全局变量myIntVar。
	Int k = 10;
	K = k + myIntVar;//使用的是名字空间的成员变量，所以k的值等于20.
	K = K + ::myIntVar;//这里使用的是全局变量，所以k的值等于110.
	{
     	Int myIntVar = 50;//在此语句作用域中声明的变量隐藏了前面using声明中引入的变量。
    	Int a  = myIntVar ;//a = 50
    	Int b  = ::myIntVar;//b = 100;
   	 	Int C  = mySpace::myIntVar;//c = 10;
	}
}
```
使用using声明将名字空间的成员引入到当前作用域的时候，除了重载函数以外，被引入的成员名称不能与当前作用域中定义的对象实体重名，否则会引起错误。


3. 第三种方式：使用using 指示符，一次引入所有名字空间成员。

Using指示符以关键字using 开头后跟关键字namespace，最后是名字空间的名称。该名字空间的名称必须在前面已经定义。其作用域从using指示符开始，直到当前作用域结束。使用using指示符以后，将会把名字空间中的所有成员引入到当前作用域。具体的代码如下：

```cpp
//定义名字空间
Namespace mySpace
{
	Int myFunction(int Para)
	{
   		Return Para*10;
	}
	Int myVar = 100;
}

//使用using指示符，将名字空间的所有成员引入到当前作用域。目前是全局作用域。
Using namespace mySpace;
Void main()
{
	Int k = myVar + 10;//使用using指示符以后，可以直接使用名字空间中的成员，就好像该//名字空间的成员在当前作用域中定义的一样，不需要限定修饰。
	myFunction(k);
}
```
在上面的代码中，首先定义了一个名字空间mySpace，同时在名字空间中定义了一个函数myFunction，以及一个变量myVar。然后使用using指示符将该名字空间中的成员引入到了全局作用域中。之后，在main函数中使用名字空间的成员，使用的时候，不需要限定修饰，就好像使用当前名字空间中定义的成员一样。

在当前作用域使用using指示符以后，被引用的名字空间将与当前的作用域合并，名字空间中的成员就好像在当前作用域被定义一样。因此，在当前作用域中，不能定义与名称空间成员重名的对象。否则会因此错误。

##### 2.5标准名字空间std
在名字空间的概念被提出之前，在C++中就已经存在了大量的库函数。这些库函数有的是标注C形式的，也有的是标准C++形式的。在声明这些库函数的时候，按照其功能和类别，它们被划分到很多不同的头文件中，如：`iostream.h`，`complox.h`，`stdio.h`。当名字空间的概念被提出之后，这些库函数被重新整理，将它们的声明和定义放到了名称空间名称为std的名称空间中。它们被称为标准C++库。

但是为了向前兼容以前实现的C++程序，在对这些库函数进行整理的时候，创建了新的头文件，并采用了新的命名规则，以区分原有的库函数。具体的处理方式描述如下：

对于支持C++的头文件，如：<iostream.h>，在被重新整理之后，它的名称为去掉了头文件的扩展名。新的头文件所包含的功能与旧头文件基本相同，但是它们在std名字空间中；
对于支持C标准的头文件，如：<stdio.h>，在被重新整理之后，它的名称为，在名称的前面加上了前缀字符“C”，并去掉扩展名。新的头文件所包含的功能与旧的头文件基本相同，但是它们在std名字空间中。
原有旧的C++标准头文件，如<iostream.h>，依然被支持，它们不在名字空间std中；
原有旧的C标准头文件，如<stdio.h>，依然被支持，它们不在名字空间std中。


##### 2.6名字空间的嵌套
在用户声明的名字空间中还可以继续嵌套其他的名字空间，通过这种分层次的名字空间的结构可以改善函数库的代码组织结构。具体代码如下：

```cpp
Namespace myFirstSpace
{
    Int myVar = 10;
    Namespace mySecondSpace
    {
       int dlVar = 314;
       Int myVar = 100;//它会隐藏外围名字空间声明的变量。
    }
}
```
只要需要，名字空间的嵌套可以一直向下持续下去。在名字空间嵌套的时候，外围名字空间声明的变量可能会被里面嵌套的名字空间声明的同名变量隐藏。在使用嵌套名字空间成员的时候，有三种方式，具体情况如下：

```cpp
//第一种形式：限定修饰名称形式
Int a = MyFirstSpace::mySecondSpace::dlVar;
//第二中形式：using声明的形式：
Using myFirstSpace::mySecondSpace::dlVar;
Int a= dlVar;
//第三中形式：using指示符形式：
Using namespace myFirstSpace::mySecondSpace;
Int a = dlVar;
```


##### 2.7未命名名字空间
使用未命名的名字空间，可以定义文件作用域。具有文件作用域的名字空间只在定义它的文件中有效，在其他文件中访问不到该作用域。

未命名名字空间的定义格式如下：
```cpp
----------------------------A.cpp--------------------------
Namespace
{
   Int a = 10;
   Void myFunction(int Para)
}
//使用未命名名字空间中的成员
Void main()
{
   myFunciton(a);//直接使用，不需要限定修饰。
}
```
在使用未命名名字空间中的成员的时候，可以直接使用，不需要限定修饰。未命名名字空间中的成员只能在定义它的文件中使用，在其他文件中是无法访问的。

注意点:
1. 在同一作用域内的**对象名,函数名,枚举常量**会隐藏同名的类名或枚举类型名.
2. 重载的函数可以有相同的函数名.


## C++中类的(static)静态成员和类的(static)静态成员函数

### 1.语法
在C语言中，我们知道有static静态变量，生命周期与作用域都跟普通变量有所不同。而在C++的类中，也有静态成员变量同时还有静态成员函数，先来看看C++中静态成员变量与静态成员函数的语法：
```cpp
#include <iostream>
#include <string>
 
using namespace std;
 
class test
{
private:
    static int m_value;		//定义类的静态成员变量
 
public:
 
    static int getValue()	//定义类的静态成员函数
    {
    	return m_value;
    }
};
 
int test::m_value = 12;		//类的静态成员变量需要在类外分配内存空间
 
int main()
{
    test t;
 
    cout << t.getValue() << endl;
    system("pause");
}
```

以上代码，我们在test类中分别定义了一个静态成员变量与静态成员函数，首先来看下静态成员变量:  
1. 静态成员变量属于整个类所有
2. 静态成员变量的生命期不依赖于任何对象，为程序的生命周期
3. 可以通过类名直接访问公有静态成员变量
4. 所有对象共享类的静态成员变量
5. 可以通过对象名访问公有静态成员变量
6. 静态成员变量需要在类外单独分配空间
7. 静态成员变量在程序内部位于全局数据区 (Type className::VarName = value)

### 2.类的静态成员的目的
针对静态成员变量的以上几点，我们把上边的代码修改如下，用于统计当前对象的个数:
```cpp
#include <iostream>
#include <string>
using namespace std;

class test
{
private:
    static int m_value;		//定义私有类的静态成员变量
 
public:
    test()
    {
    	m_value++;
    }

    static int getValue()		//定义类的静态成员函数
    {
    	return m_value;
    }
};
 
int test::m_value = 0;		//类的静态成员变量需要在类外分配内存空间

int main()
{
    test t1;
    test t2;
    test t3;
 
    cout << "test::m_value2 = " << test::getValue() << endl;	//通过类名直接调用公有静态成员函数，获取对象个数
    cout << "t3.getValue() = " << t3.getValue() << endl;		//通过对象名调用静态成员函数获取对象个数
    system("pause");
}
```
这样我们就直接能通过类名去访问静态成员函数，获取对象个数，不通过任何对象。


**静态成员是解决同一个类的不同对象之间数据和函数共享问题.**


### 3.类的静态数据成员和静态成员函数

+ 静态数据成员
> 1.用关键字static声明  
> 2.该类的所有对象维护该成员的同一个拷贝。   
> 3.必须在类外定义和初始化，用(::)来指明所属的类。

+ 静态成员函数
> 1.类外代码可以使用类名和作用域操作符来调用静态成员函数。
> 2.静态成员函数只能引用属于该类的静态数据成员或静态成员函数。


### 4.具有静态数据成员的类

```cpp
#include <iostream>
using namespace std;
class Point	
{
public:	
    Point(int xx=0, int yy=0) {X=xx; Y=yy; countP++; } 
    Point(Point &p);	
    int GetX() {return X;}
    int GetY() {return Y;}
    void GetC() {cout<<" Object id="<<countP<<endl;}
private:	
    int X,Y;
    static int countP;          //静态数据成员声明
};


Point::Point(Point &p)
{	
    X=p.X;
    Y=p.Y;
    countP++;         //所有对象共同维护同一个countP
}

int Point::countP=0; //静态数据成员定义和初始化，使用类名限制

void main()	
{	
    Point A(4,5);	
    cout<<"Point A,"<<A.GetX()<<","<<A.GetY();
    A.GetC();	
    Point B(A);	
    cout<<"Point B,"<<B.GetX()<<","<<B.GetY();
    B.GetC();	
}
```

注意:**static int countP;的访问权限是private,为什么在类外直接初始化？因为countP是静态的，被允许在类外初始化。**


### 5.具有静态数据和成员函数的Point类

共有的静态成员函数，可以通过类名或对象名来调用.
一般的非静态成员函数只能通过对象名来调用.

```cpp
#include <iostream>
using namespace std;
class Point	//Point类声明
{
public:	//外部接口
    Point(int xx=0, int yy=0) 
       {X=xx;Y=yy;countP++;}	
    Point(Point &p);  //拷贝构造函数
    int GetX() {return X;}
    int GetY() {return Y;}
    static void GetC()
     {cout<<" Object id="<<countP<<endl;}
    
private:	//私有数据成员
    int X,Y;
    static int countP;
};


Point::Point(Point &p)
{	
    X=p.X;
    Y=p.Y;
    countP++;
}

int Point::countP=0;
	
void main()	
{	
    Point A(4,5);	
    cout<<"Point A,"<<A.GetX()<<","<<A.GetY();
    A.GetC();  //对象名引用
    Point B(A);	
    cout<<"Point B,"<<B.GetX()<<","<<B.GetY();
    Point::GetC();    //类名引用
}
```


```cpp
#include<iostream>
using namespace std;
class Application
{ 
public:
    static void f(); 
    static void g();
private:
    static int global;
};

int Application::global=0;

void Application::f()
{  
    global=5;
}
void Application::g()
{  
    cout<<global<<endl;
}

int main()
{
    Application::f();
    Application::g();
    return 0;
}
```

静态成员函数在C++中的作用很强大，包括后边的介绍的单例模式、二阶构造模式，都用到静态成员函数及静态成员变量。

下边的图为静态成员函数与普通成员函数的比较
![alt text](静态成员函数与普通成员函数比较.png)



## 友元

### 1.介绍
+ 友元提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。（破坏数据封装和数据隐藏）
+ 使用友元函数和友元类，使用关键字`friend`。（友元类的所有成员函数都自动成为友元函数）
+ 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。

分类:
+ 全局函数做友元
+ 类做友元
+ 成员函数做友元


### 2.友元函数
**友元函数**：在类声明中由关键字friend修饰的非本类的函数，在它的函数体中能够通过对象名访问private 和protected成员。

访问对象中的成员必须通过对象名。


使用友元函数计算两点距离
```cpp
#include <iostream>
#include <cmath>
using namespace std;

class Point	
{ 
public:	//外部接口
    Point(int xx=0, int yy=0) {X=xx;Y=yy;}
    int GetX() {return X;}
    int GetY() {return Y;}
    friend float Distance(Point &a, Point &b); 
private:	//私有数据成员
    int X,Y;
};

float Distance( Point& a, Point& b)
{
      double dx=a.X-b.X;
      double dy=a.Y-b.Y;
      return sqrt(dx*dx+dy*dy);
}

int main()
{  
    Point p1(3.0, 5.0), p2(4.0, 6.0);
    double d = Distance(p1, p2);
    cout<<"The distance is "<<d<<endl;
    return 0;
}
```


### 3.友元类
若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都能访问对方类的private 和protected成员。(反之不成立)

```cpp
class B
{
    …
    friend class A;      //声明A为B的友元类
    …
}
```

```cpp
class A
{
    friend class B;
    public:
        void Display
        {
            cout<<x<<endl;
         }
         int Getx()
        {
            return x;
        }
        //其它成员略
    private:
        int x;
};

class B
{
    public:
        void Set(int i);
        void Display();
    private:
        A a;
};

void B::Set(int i)
{
    a.x=i;
}
void B::Display()
{
   a.Display();
}
```
B是A的友元，B的成员函数可以访问A类对象的私有数据。

注意:
+ 友元关系不能传递。
+ 友元关系是单向的。
+ 友元关系是不被继承的。



定义Boat与Car两个类，二者都有weight属性，定义二者的一个友元函数otalWeight() 计算二者的重量和。
```cpp
class Boat
{
private:
    int weight;
public:
    Boat(int j){weight = j;}
    friend int totalWeight(Car &aCar, Boat &aBoat);
};

class Car
{
private:
    int weight;
public:
    Car(int j){weight = j;}
    friend int totalWeight(Car &aCar, Boat &aBoat);
};

#include "car.h"
using namespace std;
int totalWeight(Car &aCar, Boat &aBoat)
{
    return aCar.weight + aBoat.weight;
}

int  main()
{
    Car c1(4);
    Boat b1(5);
    cout << totalWeight(c1, b1) << endl;
    return 0;
}
```



## 共享数据保护

const

+ 常引用：被引用的对象不能被更新。
const  类型说明符  &引用名
+ 常对象：必须进行初始化,不能被更新。
类名  const  对象名
+ 常数组：数组元素不能被更新。
类型说明符 const 数组名[大小]…
+ 常指针：指向常量的指针。
类型说明符 * const 指针名


### 1.常引用作形参

```cpp
#include<iostream>
using namespace std;
void display(const double& r);
int main()
{   
    double d(9.5);
    display(d);
    return 0;
}
void display(const double& r)  
//常引用做形参，在函数中不能更新 r所引用的对象。
{   cout<<r<<endl;   }

```

### 2.常对象

```cpp
class A
{
public:
    A(int i,int j) {x=i; y=j;}
                ...
private:
    int x,y;
};
const A a(3,4);   //a是常对象，不能被更新

```
+ 通过对象名访问其成员对象，由于常对象的数据成员都被视同常量，语法会限制不能赋值。
+ 规定不能通过常对象调用普通的成员函数。
+ 常对象可以调用常成员函数。


### 3.用const修饰的类成员

常成员函数
+ const是函数类型的一个组成部分，因此在定义部分也要带const关键字。
+ 类型说明符  函数名（参数表）const;
+ 常成员函数不更新对象的数据成员，也不能调用该类中没有用const修饰的成员函数。
+ 常对象只能调用它的常成员函数。
+ const关键字可以被用于参与对重载函数的区分。

常成员函数举例
```cpp
#include<iostream>
using namespace std;

class R
{   
public:
    R(int r1, int r2)
    {
        R1=r1;R2=r2;
    }
    void print();
    void print() const;
private:
    int R1,R2;
};

void R::print()
{     
    cout<<R1<<":"<<R2<<endl;
}

void R::print() const
{     
    cout<<R1<<";"<<R2<<endl;
}

void main()
{   
    R a(5,4);
    a.print(); 
    const R b(20,52);  
    b.print();
}
```


### 4.常引用
+ 非const的引用只能绑定到普通的对象，而不能绑定到常对象，但常引用可以绑定到常对象。
+ 一个对象，无论是否为常对象，一旦和const引用绑定，则不能修改它的数据成员，也不能调用非const的成员函数。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    A(int i);
    void print();
    const int& r;
private:
    const int a;
    static const int b;
};

const int A::b=10; 
A::A(int i):a(i),r(a) {}

void A::print()
{    
    cout<<a<<":"<<b<<":"<<r<<endl; 
}

int main()
{
    A a1(100),a2(0);  
    a1.print();
    a2.print();
    return 0;
}
```

## 项目一般组织结构

### 1.组织结构
+ 类定义文件（*.h文件）
+ 类实现文件（*.cpp文件）
+ 类的使用文件（*.cpp主函数文件）

![alt text](项目的组织结构.png)


决定一个声明放在源文件中还是头文件中的一般原则是：
1. 需要分配空间的定义放在源文件中（函数的定义，变量的定义等）
2. 不需要分配空间的放在头文件（类声明，外部数据类型声明。）


```cpp
//不使用条件编译的头文件
//main.cpp
#include "file1.h"
#include "file2.h"
void main()
{
    …
}

//file1.h
#include "head.h"
    …


//file2.h
#include "head.h"
    …


//head.h
    …
class Point
{
    …
}
    …
```

```cpp
//使用条件编译的头文件
//head.h
#ifndef  HEAD_H
    #define  HEAD_H
    …
    class Point
    {
        …
    }
        …
#endif
```

### 2.类对象结构演示
```cpp
//Point.h
class Point{
public:
  Point();
  //其他类成员
};
```

```cpp
//Point.cpp
#include "Point.h"
Point::Point(){
    //类成员函数实现        
}
```

```cpp
//main.cpp
#include "Point.h"
int main(){
    Point p;
    //主函数代码
    return 0;
}
```
而当我们有多个文件的时候，我们就需要手动地来进行编译与连接了——我们需要把主函数所需要的类定义与实现文件都编译成目标代码文件，然后将其与主函数编译的目标代码文件连接起来，这样才能得到一个可执行文件。

## C++类的对象数组

### 一.对象数组的定义
所谓对象数组，指每一个数组元素都是对象的数组，即若一个类有若干个对象，我们把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。

定义一个一维数组的格式如下：
**类名 数组名[下标表达式]**

与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，其一般形式为：
**数组名[下标].成员名**

在建立数组时，同样要调用构造函数。有几个数组元素就要调用几次构造函数。

### 二.对象数组初始化
+ 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象。
+ 如果没有为数组元素指定显式初始值，数组元素便使用默认值初始化（调用默认构造函数）。

原则:
1. 元素对象的初值要求相同的值：类中定义**不带参数的构造函数**或者**具有默认形参值的构造函数**。
2. 当元素对象的初值要求不同的值：类中定义**带形参的构造函数**。


#### 2.1构造函数有0个或1个参数

如果构造函数只有1个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参来实现初始化。

例 1： 用只有1个参数的构造函数给对象数组赋值。
```cpp
#include<iostream>
using namespace std;
class exam{
	public:
		exam(int n){  //只有1个参数的构造函数 
			x=n;
		}
		int get_x(){
			return x;
		}
	private:
		int x;
};
int main(){
	exam ob1[4]={11,22,33,44};  //用只有1个参数的构造函数给对象数组赋值 
	for(int i=0;i<4;i++)
		cout<<ob1[i].get_x()<<" ";
	return 0;
}
```

**当各个元素的初始值相同时，可以在类中定义不带参数的构造函数或带有默认参数值的构造函数；当各元素的对象的初值要求为不同时，需要定义带参数（无默认值） 的构造函数。**

例2： 用不带参数和带1个参数的构造函数给对象数组赋值。
```cpp
#include<iostream>
using namespace std;
class exam{
	public:
		exam(){
			x=123;
		}
		exam(int n){
			x=n;
		}
		int get_x(){
			return x;
		}
	private:
		int x;
};
int main(){
	exam ob1[4]={11,22,33,44};
	exam ob2[4]={55,66};
	exam ob3[4];
	for(int j=0;j<4;j++){
		cout<<ob1[j].get_x()<<" ";
	}
	cout<<endl;
	for(int j=0;j<4;j++){
		cout<<ob2[j].get_x()<<" ";
	}
	cout<<endl;
	for(int j=0;j<4;j++){
		cout<<ob3[j].get_x()<<" ";
	}
	return 0;
}
```

#### 2.2构造函数有多个参数
如果构造函数有多个参数，在定义对象数组时只需在花括号中分别写出构造函数并指定实参即可实现初始化。

例3： 用带有2个参数的构造函数给对象数组赋值。
```cpp
#include<iostream>
#include<cmath>
using namespace std;
class Complex{
	public:
		Complex(double r=0.0,double i=0.0):real(r),imag(i){}
		~Complex(){
			cout<<"Destructor called."<<endl;
		}
		double abscomplex(){
			double t;
			t=real*real+imag*imag;
			return sqrt(t);
		}
	private:
		double real;
		double imag;
};
int main(){
	Complex com[3]={  //定义对象数组
		Complex(1.1,2.2),  //调用构造函数，为第1个对象数组元素提供实参1.1和2.2 
		Complex(3.3,4.4),  //调用构造函数，为第2个对象数组元素提供实参3.3和4.4 
		Complex(5.5,6.6)  //调用构造函数，为第3个对象数组元素提供实参5.5和6.6	
	};
	cout<<"复数1的绝对值是："<<com[0].abscomplex()<<endl;
	cout<<"复数1的绝对值是："<<com[1].abscomplex()<<endl;
	cout<<"复数1的绝对值是："<<com[2].abscomplex()<<endl;
 	return 0;
}

```



## 类的继承与派生

### 一、概念与定义

继承和派生  
**继承机制**： 是类型层次结构设计中实现代码的复用重要手段。   
**派生**： 保持原有类特性的基础上进行扩展，增加新属性和新方法，从而产生新的类型。  

在面向对象程序设计中，继承和派生是构造出新类型的过程。呈现类型设计的层次结构，体现了程序设计人员对现实世界由简单到复杂的认识过程。

#### 1.继承的概念与定义
C++ 通过类派生（ class derivation）的机制来支持继承。被继承的类称为**基类（base class）** 或 **超类（superclass）**，新产生的类为**派生类（derived class）** 或 **子类（subclass）**。基类和派生类的集合称作**类继承层次结构（hierarchy）**。  

由基类派生出，派生类的设计形式为：
```
class 派生类名：访问限定符 基类名
{
private:
成员表1; //派生类增加或替代的私有成员
public:
成员表2; //派生类增加或替代的公有成员
protected:
成员表3; //派生类增加或替代的保护成员
}；//分号不可少
```

示例:  
定义一个person基类：  
```cpp

class Person
{
private:
    char _idPerson[20]; //身份证号,18位数字
    char _name[8]; //姓名
    int _age;
public:
    Person(){
        _idPerson[0] = '0';
        _name[0] = '0';
        _age = 1;
    }

    Person(const char* id, const char* name, int age){
        strcpy_s(_idPerson, 20, id);
        strcpy_s(_name, name);
        _age = age;
    }

    ~Person() {}

    void Dance() const
    {
        cout<<" 跳舞"<<endl;
    }

    void PrintPersonInfo() const
    {
        cout << "身份证号: " << _idPerson << 't';
        cout << "姓名: " << _name << "t";
        cout << "年龄: " << _age << endl;
    }
};
```

定义一个学生派生类，public的形式继承person基类

```cpp
// 派生类 访问限定符 基类
class Student : public Person
{
private:
    char _snum[10];
    float _score;
public:
    void Study() const
    {
        cout<<"学生学习！"<<endl;
    }

    Student():Person()
    {
        _snum[0] = '0';
        _score = 0.0;
    }

    Student(const char * id,const char * name,int age,const char * num):Person(id,name,age){
        strcpy_s(_snum,10,num);
        _score = 0.0;
    }

    ~Student() {}
    void PrintStudentInfo() const
	{
    	PrintPersonInfo();
    	cout << "学号: " << _snum << "t" << "成绩: " << _score << endl;
	}

};

```
派生类sudent可以继承基类person的成员和方法
```cpp
int main()
{
    Student studx("61010100010102345", "yhping", 23, "2022001");
    return 0;
}
```
派生类student可以调用基类person 的public和protected方法


**总结**  
派生反映了事物之间的联系，事物的共性与个性之间的关系。派生与独立设计若干相关的类，前者工作量少，重复的部分可以从基类继承来，不需要单独编程。继承是类型设计层面上的复用。


#### 2.继承与派生的实现

派生类的一般定义语法为：

```
class 派生类名：继承方式 基类名1，继承方式 基类名2，……继承方式 基类n
{
    派生类成员声明；
}；
```

一个派生类可以同时有多个基类，这种情况称为**多继承**。    
一个派生类可以只有一个基类，这种情况称为**单继承**，是多继承的一个特例。

注意点：
+ 直接派生出某类的基类称为**直接基类**，基类的基类甚至更高层的基类也称为**间接基类**。
+ 继承方式规定了如何访问从基类继承的成员。
+ 派生类成员是指除了从基类继承来的所有成员之外，新增加的数据和函数。 


#### 3.派生类的生成过程
1. **吸收基类成员**派生类继承了基类employee中除构造和析构函数之外的所有成员。
2. **改造基类成员**基类成员的访问控制问题；基类数据或函数成员的隐藏。(在派生类中声明一个和基类数据或函数的同名的成员)
3. **添加新的成员**派生类新成员的加入时继承与派生机制的核心，给派生类添加适当的数据和函数成员，来实现必要地新增功能。

```cpp
class employee    //基类
{
protected:
    int individualEmpNo;	//个人编号
    int grade;	//级别
    float accumPay;	//月薪
    static int employeeNo; //本公司职员编号目前最大值
public:
    employee();	//构造函数
    ~employee();	//析构函数
    void pay();   //计算月薪函数
    void promote(int);	//升级函数
    void SetaccumPay (float pa);  	//设置月薪函数
    int GetindividualEmpNo();  	//提取编号函数
    int Getgrade();   	//提取级别函数
    float GetaccumPay();  	//提取月薪函数
};

class technician:public employee //兼职技术人员类
{
private:
    float hourlyRate;  //每小时酬金
    int  workHhours ; // 当月工作时数
public:
    technician();  //构造函数
    void SetworkHours(int wh); //设置工作时间
    void pay();  //计算月薪函数
};
```


#### 4.继承方式

不同继承方式的影响主要体现在：    
+ 派生类成员对基类成员的访问权限
+ 通过派生类对象对基类成员的访问权限

三种继承方式:  
+ 公有继承
+ 私有继承
+ 保护继承

##### 公有继承

公有继承特点：  
+ 基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可直接访问。
+ 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
+ 通过派生类的对象只能访问基类的public成员。

公有继承举例：
```cpp
class Point	//基类Point类的声明
{
public:	//公有函数成员
    void InitP(float xx=0, float yy=0)
    {X=xx;Y=yy;}
    void Move(float xOff, float yOff)
    {X+=xOff;Y+=yOff;}
    float GetX() {return X;}
    float GetY() {return Y;}
private:	//私有数据成员
    float X,Y;
};

class Rectangle: public Point  //派生类声明
{
public:	//新增公有函数成员
    void InitR(float x, float y, float w, float h)
    {InitP(x,y);W=w;H=h;} //调用基类公有成员函数
    float GetH() {return H;}
    float GetW() {return W;}
private:	//新增私有数据成员
    float W,H;
};

#include<iostream>
#include<cmath>
using namecpace std;
int main()
{  
    Rectangle rect;
    rect.InitR(2,3,20,10);    //通过派生类对象访问基类公有成员
    rect.Move(3,2);  
    cout<<"The data of rect(X,Y,W,H):"<<endl;
    cout<<rect.GetX()<<','
        <<rect.GetY()<<','
        <<rect.GetH()<<','
        <<rect.GetW()<<endl;
    return 0; 
}
```
Rectangle类中的成员函数及对象可以访问基类的公有和保护类型的成员，但不能访问基类的私有成员。Rectangle类继承了Point类的成员，也就实现了代码的重用，同时，通过新增成员，加入自身的独有特征，达到程序的扩充。




##### 私有继承

私有继承特点：  
+ 基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。
+ 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
+ 通过派生类的对象不能直接访问基类中的任何成员。

```cpp
#include<iostream>
#include<cmath>
using namecpace std;

class Rectangle: private Point	//派生类声明
{
public:	//新增外部接口
    void InitR(float x, float y, float w, float h)
    {InitP(x,y);W=w;H=h;}	//访问基类公有成员
    void Move(float xOff, float yOff) {Point::Move(xOff,yOff);}
    float GetX() {return Point::GetX();}
    float GetY() {return Point::GetY();}
    float GetH() {return H;}
    float GetW() {return W;}
private:	//新增私有数据
    float W,H;
};



int main()
{  //通过派生类对象只能访问本类成员
    Rectangle rect;
    rect.InitR(2,3,20,10);
    rect.Move(3,2);
    cout<<rect.GetX()<<',' <<rect.GetY()<<','
        <<rect.GetH()<<','<<rect.GetW()<<endl;
    return 0;
}
```






















































































































































































































































































## 多态性

### 一、多态性的概念
多态性是指同一个函数在不同的类中具有不同的功能。  

多态性( polymorphism ) 是面向对象程序设计的重要特征。
多态是指**同样的消息被不同的类型的对象接收时导致的不同的行为**。
所谓消息就是指对类的成员函数的调用，不同的行为就是指不同的实现。

**联编**  
联编也称绑定，是指在一个源程序经过编译链接成为可执行文件的过程中，将可执行代码“缝合”在一起的步骤。其中在程序运行前就完成的称为**静态联编(前期联编)**；在程序运行时完成的称为**动态联编(后期联编)**。  

静态联编支持的多态性称为**编译时多态(静态多态)**，通过函数重载或函数模板实现；动态联编支持的多态性称为**运行时多态(动态多态)**，通过虚函数表实现。

从系统实现的角度看，多态性分为以下两类：
+ 静态多态性：又称编译时的多态性。如函数重载、运算符重载还有函数模板，都属于静态多态性。
+ 动态多态性：有称为运行时的多态性。它主要表现为**虚函数**( virtual  function )。


### 二、静态多态性
通过**函数重载**或**函数模板**实现静态多态性

#### （1）函数重载

首先，以C语言实现int, double,char 类型的比较大小函数为例：
```cpp
int my_max_i(int a,int b) { return a > b ? a : b;}
double my_max_d(double a,double b) { return a > b ? a : b;}
char my_max_c(char a,char b) { return a > b ? a : b;}
```
观察这些函数可以发现：

这些函数都执行了相同的一般性动作;
都返回两个形参中的最大值；
从用户的角度来看， 只有一种操作 ，就是判断最大值， 至于怎样完成其细节，函数的用户一点也不关心。

这种词汇上的复杂性不是 “判断参数中的最大值” 问题本身固有的， 而是反映了程序设计环境的一种局限性： **在同一个域中出现的名字必须指向一个唯实体(函数体)** 。

这种复杂性给程序员带来了一个实际问题 ,他们必须记住或查找每一个函数名字。

函数重载把程序员从这种词汇复杂性中解放出来。

##### 1.函数重载的概念
在C++中可以为两个或两个以上的函数提供相同的函数名称，只要参数类型不同，或参数类型相同而参数的个数不同， 称为函数重载。
```cpp
// my_max + 参数表
int my_max(int a,int b)
{
    return a > b ? a : b;
}
char my_max(char a,char b)
{
    return a > b ? a : b;
}
double my_max(double a,double b)
{
    return a > b ? a : b;
}
//每个同名函数的参数表是惟一
int main()
{
    int ix = my_max(12,23);
    double dx = my_max(12.23,34.45);
    char chx = my_max('a','b');
    return 0;
}
```
编译器的工作：  
  当一个函数名在同一个域中被声明多次时，编译器按如下步骤解释第二个（以及后续的）的声明。

  **如果两个函数的参数表中参数的个数或类型或顺序不同，则认为这两个函数是重载。**

例如：
```cpp
// 重载函数
void print(int a,char b);
void print(char a,int b);
```

##### 2.判断函数重载的规则
1. 如果两个函数的参数表相同， 但是返回类型不同，会被标记为编译错误：**函数的重复声明**
```cpp
int my_max(int a,int b)
{
    return a > b ? a : b;
}
unsigned int my_max(int a,int b) // error;
{
    return a > b ? a : b;
}
int main()
{
    int ix = my_max(12,23);
    unsigned int = my_max(12,23); // error;
    return 0;
}
```
2. 参数表的比较过程与**形参名无关**
```cpp
// 声明同一个函数
int my_add(int a,int b);
int my_add(int x,int y);
```
3. 如果在两个函数的参数表中，只有缺省实参不同，则第二个声明被视为第一个的重复声明
```cpp
void Print(int *br,int n);
void Print(int *br,int len = 10);
```
4. typedef 名为现有的数据类型提供了一个替换名，它并没有创建一个新类型 ，因此，如果两个函数参数表的区别只在于一个使用了typedef，而另一个使用了与 typedef 相应的类型。则该参数表被视为相同的参数列表
```cpp
typedef unsigned int u_int;
int Print(u_int a)
int Print(unsigned int b);
```
5. 当一个形参类型有 const 或 volatile 修饰时，如果形参是按**值传递**方式定义，在识别函数声明是否相同时，并不考虑 const 和 volatile 修饰符
```cpp
void fun(int a){ }
void fun(const int a) { }
```
6. 当一个形参类型有 const 或 volatile 修饰时，如果形参定义指针或引用时，在识别函数声明是否相同时，**就要考虑 const 和 volatile 修饰符**
```cpp
void fun(int *p) {}
void fun(const int *p) {}
void fun(int &a) {}
void fun(const int &a) {}
```
7. 注意函数调用的二义性
如果在两个函数的参数表中，形参类型相同，而形参个数不同，形参默认值将会影响函数的重载.
```cpp
void fun(int a){}
void fun(int a,int b){}
void fun(int a ,int b = 10);
```

##### 3.函数重载解析的步骤
1. 确定函数调用考虑的重载函数的集合, 确定函数调用中实参表的属性；
2. 从重载函数集合中选择函数 ,该函数可以在 (给出实参个数和类型 )的情况下可以调用函数；
3. 选择与调用最匹配的函数。

##### 4.名字粉碎（名字修饰）
  “C”或者“C++”函数在内部（编译和链接）通过**修饰名**识别。**修饰名是编译器在编译函数定义或者原型时生成的字符串**。

  修饰名由函数名、类名、调用约定、返回类型、参数等共同决定。



##### 5.函数重载的依据
**不要将不同功能的函数定义为重载函数**。

1. 函数形参的个数
2. 函数形参的类型
3. 形参的顺序
4. 不能把返回值作为函数重载的条件，原因是**编译器在编译时不会去判断函数的返回类型，函数只有调用后，编译器才会去验证返回类型，所以返回值不能作为函数重载的依据。**
5. 常函数 const 可以作为函数重载判断依据，原因：重载[]运算符时，有没有const的区别是：有const只读，没有const读写都可以。


**返回类型不同的函数是否可以重载?**   
两个方法方法名相同，返回值类型不同不可以构成函数重载。


函数重载是同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。不能只有函数返回值类型不同。



#### （2）运算符重载

##### 1.运算符重载的实质
运算符重载是对已有的运算符赋予多重含义

必要性:  
C++中预定义的运算符其运算对象只能是基本数据类型，而不适用于用户自定义类型（如类），因此运算符重载的目的是，**为用户自定义类型提供预定义的运算符。**

实现机制：  
将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符函数的实参。编译系统对重载运算符的选择，遵循函数重载的选择原则。


##### 2.运算符重载的规则和限制
+ 可以重载C++中除下列运算符外的所有运算符：`. .*   ::   ?:`
+ 只能重载C++语言中已有的运算符，不可臆造新的。
+ 不改变原运算符的优先级和结合性。
+ 不能改变操作数个数。
+ 经重载的运算符，其操作数中至少应该有一个是自定义类型


运算符重载的方式有两种：  
**重载为类成员函数。**
```
函数类型 operator 运算符（形参表）
{
      函数体；
}
```
**重载为友元函数。**
```
friend 函数类型 operator 运算符（形参表）
{
      函数体；
}
```


##### 3.运算符函数
运算符函数是类中声明的函数，其名称与运算符相同。 

###### 运算符函数的声明形式：
```
返回类型 operator 运算符（形参表）
{
      函数体；
}
```
+ 重载为类成员函数时:参数个数=原操作数个数-1（后置++、--除外）  
+ 重载为友元函数时:参数个数=原操作数个数，且至少应该有一个自定义类型的形参。


###### 运算符成员函数的设计: 

+ 双目运算符 B 

如果要重载 B 为类成员函数，使之能够实现表达式 `oprd1 B oprd2`，其中` oprd1` 为A 类对象，则 B 应被重载为 A 类的成员函数，形参类型应该是 `oprd2` 所属的类型。
经重载后，表达式 `oprd1 B oprd2` 相当于` oprd1.operator B `



**问题举例**  
（对复数类进行运算符重载）
```cpp
#include<iostream>
using namespace std;
class complex	//复数类声明
{
public:	//外部接口
    complex(double r=0.0,double i=0.0){real=r;imag=i;}complex operator + (complex c2); //+重载为成员函数
    complex operator - (complex c2); //-重载为成员函数
    void display();	//输出复数
private:	//私有数据成员
    double real;	//复数实部
    double imag;	//复数虚部
};	

complex complex::operator +(complex c2) 
//重载函数实现
{
    complex c;
    c.real=c2.real+real;
    c.imag=c2.imag+imag;
    return complex(c.real,c.imag);
}

complex complex::operator -(complex c2)  //重载函数实现
{
    complex c;
    c.real=real-c2.real;
    c.imag=imag-c2.imag;
    return complex(c.real,c.imag);
}

void complex::display()
{   
    cout<<"("<<real<<","<<imag<<")"<<endl; 
}

int main()     //主函数
{	
    complex c1(5,4),c2(2,10),c3;  //声明复数类的对象
    cout<<"c1="; c1.display();
    cout<<"c2="; c2.display();
    c3=c1-c2;	//使用重载运算符完成复数减法
    cout<<"c3=c1-c2=";
    c3.display();
    c3=c1+c2;	//使用重载运算符完成复数加法
    cout<<"c3=c1+c2=";
    c3.display();
}
```

+ 前置单目运算符 U
  

如果要重载 U 为类成员函数，使之能够实现表达式 U oprd，其中 oprd 为A类对象，则 U 应被重载为 A 类的成员函数，无形参。
经重载后，表达式 U oprd 相当于 oprd.operator U()


+ 后置单目运算符 ++和--

如果要重载 ++或--为类成员函数，使之能够实现表达式  oprd++ 或 oprd-- ，其中 oprd 为A类对象，则 ++或--  应被重载为 A 类的成员函数，且具有一个 int 类型形参。  
经重载后，表达式  oprd++ 相当于  oprd.operator ++(0)


**问题举例**：  
运算符前置++和后置++重载为时钟类的成员函数。  
前置单目运算符，重载函数没有形参，对于后置单目运算符，重载函数需要有一个整型形参。  
操作数是时钟类的对象。  
实现时间增加1秒钟。  

```cpp
#include<iostream>
using namespace std;
class Clock	//时钟类声明
{
public:	//外部接口
    Clock(int NewH=0, int NewM=0, int NewS=0);
    void ShowTime();
    Clock&  operator ++();  //前置单目运算符重载
    Clock operator ++(int);  //后置单目运算符重载
private:	//私有数据成员
    int Hour,Minute,Second;
};

Clock& Clock::operator ++()	//前置单目运算符重载函数
{	
    Second++;
    if(Second>=60)
    {   
        Second=Second-60;
        Minute++;
        if(Minute>=60)
        {
            Minute=Minute-60;
            Hour++;
            Hour=Hour%24;
        }
    }
    return *this;
}

//后置单目运算符重载
Clock Clock::operator ++(int)	
{	//注意形参表中的整型参数
    Clock old=*this;
    ++(*this);
    return old;
}

int main()
{
    Clock myClock(23,59,59);
    cout<<"First time output:";
    myClock.ShowTime();
    cout<<"Show myClock++:";
    (myClock++).ShowTime();
    cout<<"Show ++myClock:";
    (++myClock).ShowTime();
}
```


##### 4.运算符友元函数
如果需要重载一个运算符，使之能够用于操作某类对象的私有成员，可以此将运算符**重载为该类的友元函数**。

函数的形参代表依自左至右次序排列的各操作数。

后置单目运算符 ++和--的重载函数，形参列表中要增加一个int，但不必写形参名。    

+ 双目运算符 B重载后，表达式`oprd1 B oprd2`等同于`operator B(oprd1,oprd2 )`
+ 前置单目运算符 B重载后，表达式 `B oprd` 等同于`operator B(oprd )`
+ 后置单目运算符 ++和--重载后，表达式 `oprd B`等同于`operator B(oprd,0 )`


**问题举例**：
将+、-（双目）重载为复数类的友元函数。两个操作数都是复数类的对象。
```cpp
#include<iostream>
using namespace std;
class complex	//复数类声明
{
public:	//外部接口
    complex(double r=0.0,double i=0.0)
    { real=r; imag=i; }	//构造函数
    friend complex operator + (complex c1,complex c2);	
    //运算符+重载为友元函数
    friend complex operator - (complex c1,complex c2);	
    //运算符-重载为友元函数
    void display();	//显示复数的值
private:	//私有数据成员
    double real;
    double imag;
};			

complex operator +(complex c1,complex c2)	//运算符重载友元函数实现
{    return    complex(c2.real+c1.real, c2.imag+c1.imag);
}
complex operator -(complex c1,complex c2)	//运算符重载友元函数实现
{    return    complex(c1.real-c2.real, c1.imag-c2.imag);
} // 其它函数和主函数同例8.1

```


以友元函数形式重载Complex的运算符<<  

<<运算符只能用友元函数的形式重载，因为它的第一个操作数的类型为ostream，是标准库的类型，无法向其中添加成员函数。
`cout<<c3`相当于`operator<<(cout,c3)`;


#### （3）模板


##### 1.什么是c++的模板
程序设计中经常会用到一些程序实体：它们的实现和所完成的功能基本相同，不同的仅仅是所涉及的数据类型不同。而模板正是一种专门处理不同数据类型的机制。

**模板是泛型程序设计的基础**（泛型generic type——通用类型之意）。

函数、类以及类继承为程序的代码复用提供了基本手段，还有一种代码复用途径——类属类型（泛型），利用它可以给一段代码设置一些取值为类型的参数（注意：这些参数 的值是类型，而不是某类型的数据），通过给这些参数提供一些类型来得到针对不同类 型的代码。


下面可以看一个例子:
```cpp
#include <iostream>
using namespace std;
void swapint(int* a, int* b)
{
	int p = *a;
	*a = *b;
	*b = p;
}
void showint(int a, int b)
{
	cout << "a=" << a << "," << "b=" << b << endl;
}
void swapfloat(float* a, float* b)
{
	float p = *a;
	*a = *b;
	*b = p;
}
void showfloat(float a, float b)
{
	cout << "a=" << a << "," << "b=" << b << endl;
}

int main()
{
	int a1 = 3, b1 = 12;
	swapint(&a1, &b1);
	showint(a1, b1);
	float a2 = 12.3, b2 = 45.1;
	swapfloat(&a2, &b2);
	showfloat(a2, b2);
	return 0;
}
```
输出结果
```
a=12,b=3
 
a=45.1,b=12.3
```
这个例子就是实现了两种不同类型的两个数之间的交换，我们这里只是实现了两种，如 果要实现很多种，那代码量就非常大。如果可以只用一个函数和类来描述，那将会大大 减少代码量，并能实现程序代码的复用性，所以这里就要用到模板了.

##### 2.模板的概念
值和类型是数据的两个主要特征，它们在C++中都可以被参数化。

数据的值可以通过函数参数传递，在函数定义时数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。——这就是值的参数化。

数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当函数调用时，编译器根据传入的实参自动推断数据类型。——这就是类型的参数化(把类型 定义为参数)

带有类型参数的一段代码，实际上代表了一类代码，可以实现代码的复用，常用模板来实现。

模板——是一段带有类型参数的程序代码，可以通过给这些参数提供一些类型来得到针对不同类型的具体代码。

模板是C++中支持泛型编程的重要方法，是实现代码复用的工具，是实现参数化多态（类型参数化）的手段，减轻了编程及维护的工作量和难度。

一个模板并非一个实实在在的类或函数，仅仅是一个类或函数的描述。模板是规则，通过模板可以演化出多个具体的类或函数。

在C++中，能带有类型参数的代码可以是函数和类，所以模板一般分为函数模板和类模板。



##### 3.函数模板

###### 3.1什么是函数模板

例如：我们求两个数相加的函数，实现int、float、double等多种类型数据相加

如果不使用模板的话，我们可以利用重载函数，定义多个同名函数实现函数重载， 但是采用函数重载，代码重复率高，可维护性极差。

这里可以采用函数模板，定义一个add函数模板，借助它实现多种类型数据相加

函数模板——实际上是定义一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）均被作为参数：不指定具体类型，而是用一个虚拟 的类型来代替（实际上是用一个标识符来占位）。凡是函数体相同的函数都可以用 这个模板来代替，在函数调用时根据传入的实参来逆推出真正的类型。这个通用函 数就称为函数模板。

通过函数模板实现类型参数化，即把类型定义为参数，从而实现代码复用。

可见：函数模板并不是一个可以直接使用的函数，它是可以产生多个函数的模板。

###### 3.2函数模板的定义格式
```
template <typename 形参名, typename 形参名...>     
//模板头（模板说明）

返回值类型  函数名（参数列表）                   
//函数定义
{
    函数体;
}
```
说明：
1. template是声明模板的关键字，告诉编译器开始泛型编程。
2. 尖括号<>中的typename是定义形参的关键字，用来说明其后的形参名为类型参数,（模板形参）。Typename（建议用）可以用class关键字代替，两者没有区别。
3. 模板形参（类属参数）不能为空（俗成约定用一个大写英文字母表示），且在函数定义部分的参数列表中至少出现一次。与函数形参类似，可以用在函数定义的各个位置：返回值、形参列表和函数体。
4. 函数定义部分：与普通函数定义方式相同，只是参数列表中的数据类型要使用 尖括,号<>中的模板形参名来说明。当然也可以使用一般的类型参数。


###### 3.3案例
用函数模板实现多种类型数据的相加
```cpp
#include <iostream>
using namespace std;
template<typename T>//模板头，template关键字告诉编译器开始泛型编程
T add(T t1, T t2)//类型参数化为T
{
	return t1 + t2;
}
int main()
{
	cout << add(12, 34) << endl;
	cout << add(12.2,45.6) << endl;
	return 0;
}
```
输出结果
```
46
 
57.8
```
当调用add()函数传入int型参数12和参数34时，形参T被替换成int，得到结果 为46

当传入float型参数12.2和参数45.6时，形参T被替换成float，得到结果为57.8

避免了为int型定义一个求和函数，再为float型定义一个求和函数，实现了代码复用.

利用模板实现了不同类型的变量相加，可以发现利用模板的话大大减少了代码量，提高了代码复用性.

```cpp
#include <iostream>
using namespace std;
template< class  T >	//声明函数模板,或template <typename T>
void outputArray( const T *P_array, const int count )//定义函数体
{  
    for ( int i = 0; i < count; i++ )
        cout << P_array[ i ] << " ";
    cout << endl;
}

int main()	 //主函数
{
    const int aCount = 8, bCount =8, cCount = 20;
    int aArray[ aCount ] = { 1, 2, 3, 4, 5,6,7,8 };	//定义int数组
    double bArray [ bCount ] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7,8.8 }; 
    //定义double数组
    char cArray [ cCount ] = "Welcome to see you!";	//定义char数组
    cout << " a Array contains:" << endl;
    outputArray( aArray, aCount );	//调用函数模板
    cout << " b Array contains:" << endl;
    outputArray( bArray, bCount );	//调用函数模板
    cout << " c Array contains:" << endl;
    outputArray( cArray, cCount );	//调用函数模板
}
```
函数模板中声明了类型参数T，表示一种抽象的类型。当编译器检测到程序中调用函数模板outputArrary时，便用outputArrary的第一个
参数的类型替换掉整个模板定义中的T，并建立用来输出指定类型数组的一个完整的函数，然后再编译这个新建的函数。


注意：对函数模板的调用应使用实参推演来进行。
```cpp
add(2,3)  或 int a=2,b=3;  add(a,b)
//对，编译器会根据传入的实际参数2、3推演出传入的是int类型参数，则T为int 类型
add(int, int)   //错，不能在函数调用的参数中指定模板形参的类型来直接将类型传入
```

###### 3.4函数模板的实例化

定义好的函数模板不可以直接使用，只相当于一个模具、规则，可使用不同类型的参数来调用，可减少代码的书写，提高代码复用性。**但使用函数模板不会减少最终可执行程序的大小，因为在调用函数模板时，编译器会根据调用时的参数类型进行相应的实例化。**

不能直接使用函数模板实现具体操作，必须对模板进行实例化，即将模板参数实例化，就是用具体的类型参数去替换函数模板中的模板参数，生成一个确定的具体类型的真正函数，才能实现运算操作。

函数模板实例化的方法有两种：
1. 隐式实例化：根据具体的函数调用形式，推演出模板参数类型。
2. 显式实例化：通过显式声明形式指定模板参数类型。

（1）隐式实例化
根据函数调用时传入的数据类型，推演出模板形参类型。模板形参的类型是隐式确定的。

比如上面的多种类型相加.
第一次调用add()函数模板：add(12,34)，
1. 编译器根据传入的实参（12和34—>int型），推演出模板形参类型是int  
2. 会将函数模板实例化出一个int类型的函数：
```cpp
int add(int t1, int t2)
{
        return t1 + t2;
}
```
编译器生成具体类型函数的过程称为实例化，生成的函数称为模板函数。
3. 生成int类型的函数后，再将实参12和34传入进行运算。

第二次调用add()函数模板：add(12.2, 45.6)

实参为float类型的数据，编译器先将模板实例化为如下模板函数后，再将实 参12.2和45.6传入进行运算：
```cpp
float add(float t1, float t2)
{
        return t1 + t2;
}
```
可见：每次调用都会根据不同的类型实例化出不同类型的函数，所以最终可执 行程序的大小并不会减少，只是提高了程序员对代码的复用。

存在的问题：隐式实例化不能为同一个模板形参指定两种不同的类型。例如： add(1, 1.2)，这样调用，两种形参类型不同，编译器会出错。

**解决方法：采用显式实例化。**

（2）显式实例化
通过显式声明形式指定模板参数类型。

显式实例化语法格式：
```
template 函数返回值类型 函数名<实例化的类型>(参数列表);
```
注意：这是声明语句，要以分号结束，<>中是显式实例的数据类型，即要实例化出一个什么类型的函数。如：显示实例化为int，则在调用时，不是int类型的数据会转换为int类型进行计算。

例如：将例5-1中的add()函数模板显式实例化为int类型
```cpp
template int add<int>(int t1, int t2);
```
```cpp
#include <iostream>
using namespace std;
template<typename T>
T add(T t1, T t2)
{
		return t1 + t2;
}
template int add<int>(int t1, int t2);//显示实例化为int类型
int main()
{
		cout << add<int>(12, 'A') << endl;//函数模板调用：A-65
		cout << add(1.4, 5.7) << endl;//隐式实例化：自动实参推演
		cout << add<int>(23.4, 44.2) << endl;//显示声明可省，结果为67
		return 0;
}
```
输出结果
```
77
 
7.1
 
67
```
上面利用显示实例化指定模板参数是int类型，所以在调用函数时会自动将参 数转换为int类型。比如上面在调用int类型模板函数时，传入一个字符’A’, 则编译器会将字符类型的’A’转换为int类型，然后再与12相加得出结果

注意：对于给定的函数模板实例，显式实例化声明在一个文件中只能出现一次，并且在这个文件中必须给出函数模板的定义，如果定义不可见就会发生错误。

C++编译器也在不断完善，模板实例化的显式声明有时可以省略，只在调用时 用<> 显式指定要实例化的类型也可以。

例如：add(23.4, 44.2)函数调用如果改为add<int> (23.4, 44.2)，则也会得出结果 67



###### 3.5函数模板的重载
前面学习过函数的重载。而函数模板可以用来创建一个通用功能的函数，以支持多 种不同形参，不同类型的参数调用，就产生一系列重载函数。

比如定义一个两个数相加的模板   
根据传入参数不同，会实例化出不同的函数，比如:
```cpp
template<typename T>
T add(T t1, T t2)
{
	return t1 + t2;
}
```
根据传入参数不同，会实例化出不同的函数，比如
```cpp
int add(int t1, int t2)            //int类型参数实例化出的函数
{
        return t1 + t2;
}

double add(double t1, double t2)  //double类型参数实例化出的函数
{
        return t1 + t2;
}
```
最终运行的程序中会有这两个函数，实际上就是重载函数，调用时会根据传入的参数类型来调用相应的函数.

此外，函数模板本身也可以重载，即相同函数模板名可以具有不同的函数模板定义，当进行函数调用时，编译器根据实参的类型与个数来决定调用哪个函数模板来实例化一个函数.

比如：定义一个求两个任意类型数据最大值的函数，还要定义一个求三个任意类型数据最大值的函数，都是求任意类型数据的最大值，可以定义重载的函数模板来实现.
```cpp
#include <iostream>
using namespace std;
int maxx(int a, int b) //非模板函数，求两个int类型数据的最大者
{
	cout << "调用非模板函数" << endl;
	return a > b ? a : b;
}
template<typename T>//定义求两个任意类型数据的最大值
T maxx(const T t1, const T t2)
{
	cout << "调用两个参数的模板函数" << endl;
	return t1 > t2 ? t1 : t2;
}
template<typename T>//定义求三个任意类型数据的最大值
T maxx(T t1, T t2, T t3)
{
	cout << "调用三个参数的模板函数" << endl;
	return max(max(t1, t2), t3);
}
int main()
{
	cout << maxx(1, 2) << endl;//调用非模板函数
	//当函数模板和普通函数都符合调用时,优先选择普通函数
	cout << maxx(1, 2, 3) << endl;//调用三个参数的函数模板
	cout << maxx('a', 'c') << endl;//调用两个参数的函数模板
    cout << maxx(6, 3.2) << endl;//调用非模板函数
	cout << maxx<>(1, 2) << endl;   //若显示使用函数模板,则使用<> 类型列表
	cout << maxx(3.0, 4.0) << endl;  //如果函数模板产生更好的匹配使用函数模板
	cout << maxx(5.0, 6.0, 7.0) << endl;  //重载
	//cout<<max('a', 100)<<endl;  //调用普通函数（报错）
	return 0;
}
```
输出结果
```
调用非模板函数
2
调用三个参数的模板函数
3
调用两个参数的模板函数
C
调用非模板函数
6
调用两个参数的模板函数
2
调用两个参数的模板函数
4
调用三个参数的模板函数
7
```
从运行结果可以看出来，当函数模板和普通函数都符合调用时，优先选择普通函数.

但如果函数模板能够更好地实例化一个匹配的函数，则调用时将选择函数模板，比 如上面的maxx(3.0,4.0).

注意：如果有不同类型参数，则只允许使用非模板函数，因为模板是不允许自动类型转化的，但普通函数可以进行自动类型转换.

###### 3.6函数模板与普通函数小结

**两者的区别：函数模板不允许自动类型转化，普通函数则能进行自动类型转换**

函数模板和普通函数在一起时的调用规则：
+ 函数模板可以像普通函数一样被重载
+ C++编译器优先考虑普通函数
+ 如果函数模板可以产生一个更好的匹配，那么选择模板
+ 可以通过空模板实参列表的语法限定编译器只通过模板匹配


###### 3.7使用函数模板要注意的问题

(1)函数模板中的每一个类型参数在函数参数表中必须至少使用一次。例如：下 面的函数模板声明是不正确的：函数模板声明了两个参数T1与T2，但在使用时只使用了T1，没使用T2。
```cpp
template <typename T1,typename T2>
void func(T1 t)
{
    //……
}
```
（2）在全局域中声明的与模板参数同名的对象、函数或类型，在函数模板中将被隐藏。例如：在函数体内访问num是访问的T类型的num，而不是全局变量num
```cpp
int num;
template <typename T>
void func(T t)
{
    T num;
}
```
(3)函数模板中定义声明的对象或类型不能与模板参数同名。例如：
```cpp
template <typename T>
void func(T t)
{
    Typedef float T;  //错误，定义的类型与模板参数名相同
    //……
}
```
（4）模板参数名在同一模板参数表中只能使用一次，但可在多个函数模板声明或定义之间重复使用。例如：
```cpp
template <typename T, typename T>  //错误，在同一个模板中重复定义模板参数
void func1(T t1, T t2) { }
template<typename T>
void func2(T t1) { }
template <typename T>    //在不同函数模板中可重复使用相同模板参数名
void func3(T t3) { }
```
（5）模板的定义和多处声明所使用的模板参数名不一定要必须相同。例如：
```cpp
//模板的前向声明
template <typename T>
void func1(T t1,T t2);
//模板的定义
template <typename U>
void func1(U t1, U t2)
{
    //……
}
```
（6）函数模板如果有多个模板参数，则每个模板类型前都必须使用关键字typename 或class修饰。例如：
```cpp
template <typename T, class U>   //两个关键字可以混用
void func(T t, U u)  { }
template <typename T,U>        //错误，每一个模板参数前都要有关键字修饰
void func(T t, U u)  { }
```


##### 4.类模板

除了函数模板外，C++中还支持类模板。类模板是对成员数据类型不同的类的抽象，它说明了类的定义规则，一个类模板可以生成多种具体的类。与函数模板的定义形式类似， 类模板也是使用template关键字和尖括号“<>”中的模板形参进行说明，类的定义形式与普通类相同。

类模板并不能直接使用，需要对其进行实例化，实例化的方法是：类名<具体类型> 对象名。通过类模板实例化得到的对象的操作办法，与普通类对象的操作办法相同。

###### 4.1定义类模板的格式

与函数模板的定义形式类似，类模板也是使用template关键字和尖括号“<>”中 的模板形参进行说明，类的定义形式与普通类相同。格式如下：
```cpp
template<typename 形参名,typename 形参名…>
class 类名
{
    ………
}
```
说明：
（1）类模板中的关键字含义与函数模板相同。
（2）类模板中的类型参数可用在类声明和类实现中。类模板的模板形参（类型参数）不能为空，一旦声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即在类中使用内置数据类型的地方都可以使用模板形参名来代替。

例如：
```cpp
template<typename T>   //这里不能有分号。一个模板形参
class A
{
public:
    T a;   //成员变量
    T b;   //成员变量
    T func(T a, T b);  //成员函数声明
};
```

###### 4.2类与类模板的关系
由于类模板包含类型参数，因此也称为参数化类，如果说类是对象的抽象，对象是类的实例，则类模板是类的抽象，类是类模板的实例。

###### 4.3类模板的实例化
定义了类模板后就要使用类模板创建对象以及实现类中的成员函数，这个过程其实也是类模板实例化的过程，实例化出的具体类称为**模板类**。


(1)使用类模板创建对象时，**必须**指明具体的数据类型。
例如：用上述定义的模板类A创建对象，则在类A后面跟<>，并在里面表明相应的类型：

`A<int>  a`;//类A中凡是用到模板形参的地方都会被int类型所代替

强调：与函数模板不同的是，类模板在实例化时，必须在尖括号中为模板形参显式地指明数据类型（实参），编译器不能根据给定的数据推演出数据类型。即：不存在将整型值10推演为int类型传递给模板形参的实参推演过程，必须要在<>中指定int类型。

（2）当类模板有两个模板形参时，创建对象时，类型之间要用逗号分隔开。
```cpp
template<typename T1, typename T2>
class B
{
public:
    T1 a;
    T2 b;
    T1 func(T1 a, T2& b);
};
B <int, string>  b;    //创建模板类B的一个对象
```

（3）可以使用对象指针的方式来实例化
```cpp
Point<float, float> *p1 = new Point<float, float>(10.6, 109.3);
Point<char*, char*> *p = new Point<char*, char*>("东京180度", "北纬210度");
```
注意：赋值号两边都要指明具体的数据类型，且要保持一致。


（4）案例
定义一个类模板实现两个数比较大小（求两数的大者与小者）
```cpp
#include <iostream>
using namespace std;
template<typename T>
class Compare
{
private:
	T t1, t2;
public:
	Compare(T a, T b) :t1(a), t2(b) {}
	T max() { return t1 > t2 ? t1 : t2; }
	T min() { return t1 < t2 ? t1 : t2; }
};
int main()
{
	Compare<int> c1(1, 2);          //定义int类型的类对象
	cout << "int max: " << c1.max() << endl;
	Compare<double> c2(1.2, 3.4);    //定义double类型的对象
	cout << "double min: " << c2.min() << endl;
	Compare<char> c3('a', 'b');        // 定义char类型的对象
	cout << "char max: " << c3.max() << endl;
	return 0;
}
```
输出结果
```
int max: 2
double min: 1.2
char max: b
```

创建对象时，在类名后<>中指定模板形参的类型，编译器先根据类型实例化出一个具体的类，然后再创建这个具体实例的对象。

`Compare<int> c1(1, 2)`语句，在编译时创建一个类：
```cpp
class Compare
{
private:
    int t1, t2;
public:
    Compare(int a, int b) :t1(a), t2(b){}
    int max(){ return t1 > t2 ? t1 : t2; }
    int min(){ return t1 < t2 ? t1 : t2; }
};
```
然后再根据这个类创建对象c1。这和函数模板一样，都不会减少最终执行程序的代码。    


说明：

如果对函数模板add(T t1, T t2)进行add(1, 1.2)调用，则编译会报错，因为指定了两 种类型的参数，编译器无法确定依据哪个参数来调用。但对于类模板来说，编译器 则不会报错。
```cpp
template<typename T>
class A
{
public:
        A( ) { };
        T add(T t1, T t2)
        {
                return t1+t2;
        }
};
A<int> a;     //定义对象a
```
a.add(1,1.2);   //不会报错。因为在定义对象a时就已经指定是int类型，当add()函数模板实例化时也会实例化出一个int类型的函数，它会自动将double类型的1.2转换为int类型的1。


（5）模板声明或定义的作用域
模板的声明或定义只能在全局、命名空间或类范围内进行，不能在局部范围、函数 内进行，比如不能在main()函数中声明或定义一个模板。声明或定义一个模板还有 以下几点需注意：

1. 如果在全局域中声明了与模板参数同名的变量，则该变量被隐藏。
2. 模板参数名不能被当作类模板定义中类成员的名字。
3. 同一个模板参数名在模板参数表中只能出现一次。
4. 在不同的类模板声明或定义中，模板参数名可以被重复使用。

（6）在类模板外部定义成员函数
类中的成员函数既可以在类中定义，也可以在类外定义。类模板中的成员函数同样可以在类模板的定义中定义，也可以在类模板定义之外定义，只是**在类外定义成员函数时需要带上模板头：template<模板参数表>。**

在类模板外部定义成员函数的方法
```
template<模板形参表>
函数返回类型 类名<模板形参名>::函数名（参数列表）｛｝
```
说明：
+ template是类模板的声明，在实现成员函数时，也要加上类作用域，而且在类名后要用<>指明类的模板形参。
+ template后的模板形参应与要定义的类模板形参一致。

例如：有下列类模板的定义
```cpp
template<typename T1, typename T2>  //模板头
class B
{
public:
        T1 a;
        T2 b;
        T1 func(T1 a, T2& b);
};
```
如果在类模板外定义类B的成员函数func()，其实现如下：
```cpp
template<typename T1, typename T2>
T1 B<T1,T2>::func(T1 a, T2& b) { }
```
```cpp
#include <cstdlib>
#include <iostream>
using namespace std;
template<typename T>   //类模板
class Array
{
private:
	int size;
	T* ptr;
public:
	Array(T arr[], int s);   //构造函数
	void show();
};
template<typename T>   //类模板外定义其成员函数
Array<T>::Array(T arr[], int s)
{
	ptr = new T[s];
	size = s;
	for (int i = 0; i < size; i++)
	{
		ptr[i] = arr[i];
	}
}
template<typename T>   //类模板外定义其成员函数
void Array<T>::show()
{
	for (int i = 0; i < size; i++)
		cout << *(ptr + i) << " ";
	cout << endl;
}
int main()
{
	char cArr[] = { 'a', 'b', 'c', 'd', 'e' };
	Array<char> a1(cArr, 5);   //创建类模板的对象
	a1.show();
	int iArr[10] = { 1, 2, 3, 4, 5, 6 };
	Array<int> a2(iArr, 10);
	a2.show();
	system("pause");
	return 0;
}
```
输出结果
```
a b c d e
 
1 2 3 4 5 6 0 0 0 0
```
注意：类模板在实例化时，带有模板形参的成员函数并不随着自动被实例化，只有当它被调用或取地址时，才被实例化。

上面创建了两个函数，一个构造函数，一个show函数，主要是在类外定义成员函数的实现方式掌握就行.


(7)类模板实例
```cpp
template <class T>  
          //类模板：实现对任意类型数据进行存取
class Store
{   private:
        T item;         // 用于存放任意类型的数据
        int haveValue;  // 用于标记item是否已被存入内容
    public:
        Store();    // 默认形式（无形参）的构造函数
        T GetElem();  //提取数据函数
        void PutElem(T x);  //存入数据函数
};

// 默认形式构造函数的实现
template <class T>                              
Store<T>::Store(void): haveValue(0) {}

template <class T>      // 提取数据函数的实现
T Store<T>::GetElem(void)    
{   // 如果试图提取未初始化的数据，则终止程序
    if (haveValue == 0)
    {  cout << "No item present!" << endl;
        exit(1);
    }
    return item;    // 返回item中存放的数据 
}

template <class T>     // 存入数据函数的实现 
void Store<T>::PutElem(T x)
{   haveValue++;      // 将haveValue 置为 TRUE，表示item中已存入数值
    item = x;         // 将x值存入item
}


int main()
{   Student g= {1000, 23};  
    Store<int> S1, S2; 
    Store<Student> S3;
    Store<double> D; 	
    S1.PutElem(3); 
    S2.PutElem(-7); 
    cout << S1.GetElem() << "  " << S2.GetElem() << endl; 
    S3.PutElem(g); 
    cout << "The student id is " << S3.GetElem().id << endl;
    cout << "Retrieving object D  " ;
    cout << D.GetElem() << endl;  //输出对象D的数据成员
    // 由于D未经初始化,在执行函数D.GetElement()时出错
}

```

##### 5.类模板与友元函数
普通的类中可以声明友元函数和友元类，同样在类模板中也可以声明友元函数和友元类。 类模板中的友元函数可以有三种形式：**非模板友元函数、约束模板友元函数、非约束模板友元函数。**


###### 5.1非模板友元函数
非模板友元就是在类模板中声明普通的**友元函数**和**友元类**。   
例如：在一个类模板中声明一个友元函数   

```cpp
template <typename T>
class A
{
    T  t;
public:
    friend void func();
}
```

在类模板A中声明了一个普通的友元函数func()，func()函数是类模板A所有实例的友元函数，它可以访问全局对象，也可以使用全局指针访问非全局对象，可以创建自己的对象，也可以访问独立于对象的模板的静态数据成员.

类模板的友元函数也可以拥有模板参数，用于操作类模板对应实例类型的对象.

例如：
```cpp
template <typename T>
class A
{
    T  t;
public:
    friend void show(const A<T>& a);
}
```
说明：show()函数并不是模板函数，只是使用一个模板作参数，这就要求在使用友元函数时必须要显式具体化，指明友元函数要引用的参数的类型。   

例如：
```cpp
void show(const A<int>& a);  //模板形参为int类型的show()函数是A<int>类的友元函数
void show(const A<double>& a);
//模板形参为double类型的show()函数是A<double>类的友元函数
```
```cpp
#include <cstdlib>
#include <iostream>
using namespace std;
template<typename T>
class A
{
	T x;
public:
	A(const T& t)
	{
		x = t;
	}
	friend void show(const A<T>& a);//有参友元函数
};
void show(const A<int>& a)//模板形参为int类型（显示具体化）
{
	cout << "int:" << a.x << endl;
}
void show(const A<double>& a)//模板形参为double类型（显示具体化）
{
	cout << "double:" << a.x << endl;
}
int main()
{
	A<int> a(10);//创建int类型对象
	show(a);
	A<double> b(12.5);//创建double类型对象
	show(b);
	return 0;
}
```

输出结果
```cpp
int:10
double:12.5
```
注意：在调用有模板形参的友元函数时，要对友元函数显式具体化，它们是各自相 同类型的对象的友元函数。


###### 5.2约束模板友元函数
这种友元函数本身就是一个函数模板，但其实例化类型取决于类被实例化时的类型 （被约束）。每个类的实例化都会产生一个与之匹配的具体化的友元函数。


（1）在类定义的前面声明函数模板
```cpp
template<typename T>
void func();
template<typename T>
void show(T& t);
```

（2）在类模板中将函数模板声明为类的友元函数
```cpp
template<typename U>
class A
{        
             ……     
    friend void func<U>();   //友元函数模板
    friend void show<>(A<U>& a);   //友元函数模板
};
```
说明：函数名后的<>指出函数模板要实例化的类型，它是由类模板的参数类型决定的。

例如：如果定义一个类模板对象：A <int> a，则编译器会生成下面类定义：
```cpp
class A
{         
    ……
    friend void func<int>();
    friend void show<>(A<int>& a);
};
```
类中友元函数模板会根据类的实例化类型而实例化出与之匹配的具体函数。

注意：类模板的实例化不会实例化一个友元函数，只是声明友元而不实例化， 只有在调用时，函数才会实例化。

上述友元函数声明中，show()函数有类的引用作为参数，可以从函数参数推断 出模板类型参数，所以其函数名后的<>可以为空。

(3)为友元函数模板提供定义   
为函数模板提供定义，必须在类内声明，类外定义。
例如：
```cpp
template<typename T>
void func() { cout << A<T>::成员 << endl; }
template<typename T>
void show(T& t) { cout << t.成员 << endl; }
```
例如：
```cpp
#include <cstdlib> 
#include <iostream>
using namespace std;
//（1）函数模板声明
template<typename T>
void func();
template<typename T>
void show(T& t);
//类模板定义
template <typename U>
class A
{
private:
	U item;
	static int count;
public:
	A(const U& u) :item(u) { count++; }
	~A() { count--; }
	//（2）在类模板中将函数模板声明为类的友元函数
	friend void func<U>();   //友元函数模板
	friend void show<>(A<U>& a);   //友元函数模板
};
template<typename T>
int A<T>::count = 0;     //类A的T类型对象的个数
//（3）友元函数模板的定义
template<typename T>
void func()
{
	cout << "template size: " << sizeof(A<T>) << ";";
	cout << " template func(): " << A<T>::count << endl;
}
template<typename T>
void show(T& t)
{
	cout << t.item << endl;
}
int main()
{
	func<int>();    //调用int类型的函数模板实例，int类型，其大小为	4字节
	A<int> a(10);   //定义类对象
	A<int> b(20);
	A<double> c(1.2);
	show(a);   //调用show()函数，输出类对象的数据成员值
	show(b);
	show(c);
	cout << "func<int> output:\n";
	func<int>();    //运行到此，已经创建了两个int类型对象
	cout << "func<double>() output:\n";
	func<double>();
	system("pause");
	return 0;
}
```
输出结果
```
template size: 4; template func(): 0
10
20
1.2
func<int> output:
template size: 4; template func(): 2
func<double>() output:
template size: 8; template func(): 1
```
分析：将func()与show()函数定义成了模板并声明为类的友元，在定义函数模 板时是在类外定义的，当调用函数时，func()函数后带有<>说明函数的实例化 类型，而show()是直接调用的。



###### 5.3非约束模板友元函数
在类内部声明友元函数模板，友元函数的模板形参与类模板的形参没有联系，此时 友元函数为类模板的非约束模板友元函数。

例如：
```cpp
template<typename T>
class A
{         ……
         template<typename T, typename U>  //在类内部声明函数模板
         friend void show(T& t, U& u);
};
```
非约束模板友元函数模板在类内声明，在类外定义；它是类模板每个实例的友元， 可以访问所有实例的类成员。

例如：
```cpp
#include <cstdlib>
#include <iostream>
using namespace std;
template<typename T>
class A
{
private:
	T item;
public:
	A(const T& t) :item(t) {}
	template<typename U, typename V>  //在类内部声明函数模板
	friend void show(U& u, V& v);
};
template<typename U, typename V>
void show(U& u, V& v)
{
	cout << u.item << "," << v.item << endl;
}
int main()
{
	A<int> a(10);
	A<int> b(20);
	A<double> c(1.2);
	cout << "a,b: ";
	show(a, b);
	cout << "a,c: ";
	show(a, c);
	system("pause");
	return 0;
}
```
输出结果
```
a,b: 10,20
 
a,c: 10,1.2
```
分析：函数模板的形参类型与类模板的形参类型不相关，因此，它可以接受任何类型的参数：第一次调用传入的是两个int类型的类对象，第二次调用传入的是一个 int类型和一个double类型的对象。





### 三、动态多态性
动态多态性是指：基类指针或引用可以指向派生类对象，并调用派生类中重写的函数。


#### (1)动态多态性的定义及实现

##### 1.重写/覆盖 的要求  
重写/覆盖： 子类中有一个跟父类完全相同的虚函数，子类的虚函数重写了基类的虚函数。  
即：子类父类都有这个虚函数 + 子类的虚函数与父类虚函数的 函数名/参数/返回值 都相同 -> 重写/覆盖（注意：参数只看类型是否相同，不看缺省值）

##### 2.多态两个要求
+ 被调用的函数必须是虚函数，子类对父类的虚函数进行重写 （重写：三同（函数名/参数/返回值）+虚函数）  
+ 父类指针或者引用去调用虚函数。

##### 3.多态的切片示意图
（1）示例1：给一个student的子类对象（临时对象也行），然后把这个对象赋给一个父类指针，通过这个父类指针就可以访问student子类的虚拟函数。
![alt text](多态切片.png)
（2）示例2：假设B是子类，A是父类，new一个B类的临时对象，然后把这个临时对象赋给一个父类指针A* p2，通过这个父类指针p2就可以访问子类B的虚拟函数func。
![alt text](切片实例.png)



##### 4.多态演示
```cpp
class Person {
public:
	Person(const char* name)
		:_name(name)
	{}
 
	// 虚函数
	virtual void BuyTicket()
    { 
        cout << _name << "Person：买票-全价 100￥" << endl;
    }
 
protected:
	string _name;
	//int _id;
};
 
class Student : public Person {
public:
	Student(const char* name)
		:Person(name)
	{}
 
	// 虚函数 + 函数名/参数/返回值 -》 重写/覆盖
	virtual void BuyTicket() 
    { 
        cout << _name << " Student：买票-半价 50 ￥" << endl; 
    }
};
 
void Pay(Person& ptr)
{
	ptr.BuyTicket();
}
 
int main()
{
        string name;
		cin >> name;
		Student s(name.c_str());
		Pay(s);
}
```


**买票场景下的多态 完整代码**  
买票场景下的多态，完整代码：    
普通人 买票时，是全价买票；   
学生 买票时，是半价买票；   
军人 买票时是优先买票。  


```cpp
class Person {
public:
	Person(const char* name)
		:_name(name)
	{}
 
	// 虚函数
	virtual void BuyTicket() { cout << _name << "Person：买票-全价 100￥" << endl; }
 
protected:
	string _name;
	//int _id;
};
 
class Student : public Person {
public:
	Student(const char* name)
		:Person(name)
	{}
 
	// 虚函数 + 函数名/参数/返回值 -》 重写/覆盖
	virtual void BuyTicket() { cout << _name << " Student：买票-半价 50 ￥" << endl; }
};
 
class Soldier : public Person {
public:
	Soldier(const char* name)
		:Person(name)
	{}
 
	// 虚函数 + 函数名/参数/返回值 -》 重写/覆盖
	virtual void BuyTicket() { cout << _name << " Soldier：优先买预留票-88折 88 ￥" << endl; }
};
 
// 多态两个要求：
// 1、子类虚函数重写的父类虚函数 （重写：三同（函数名/参数/返回值）+虚函数）
// 2、父类指针或者引用去调用虚函数。
 
//void Pay(Person* ptr)
//{
//	ptr->BuyTicket();
//}
 
void Pay(Person& ptr)
{
	ptr.BuyTicket();
}
 
// 不能构成多态
//void Pay(Person ptr)
//{
//	ptr.BuyTicket();
//}
 
int main()
{
	int option = 0;
	cout << "=======================================" << endl;
	do 
	{
		cout << "请选择身份：";
		cout << "1、普通人 2、学生 3、军人" << endl;
		cin >> option;
		cout << "请输入名字：";
		string name;
		cin >> name;
		switch (option)
		{
    		case 1:
    		{
                Person p(name.c_str());
                Pay(p);
                break;
    		}
    		case 2:
    		{
                Student s(name.c_str());
                Pay(s);
                break;
    		}
    		case 3:
            {
                Soldier s(name.c_str());
                Pay(s);
                break;
    		}
    		default:
            {
    			cout << "输入错误,请重新输入" << endl;
    			break;
    		}
        }
		cout <<"=======================================" << endl;

	} while (option != -1);
	return 0;
}
```

**重要技术细节**  
父类指针或者引用去调用虚函数，传值调用不构成多态。   
用子类也不行，必须用父类，比如你用个student，那么你的Person或者Soldier就传不进形参。

```cpp
void Pay(Person* ptr)     //指针调用可以
{
	ptr->BuyTicket();
}
 
void Pay(Person& ptr)    //引用调用可以
{
	ptr.BuyTicket();
}
 
// 不能构成多态
//void Pay(Person ptr)    //传值调用不可以
//{
//	ptr.BuyTicket();
//}
```


##### 5.虚函数重写的例外

**协变(父类与子类虚函数返回值类型不同)**
子类重写父类虚函数时，与父类虚函数返回值类型不同，称为**协变**。

虚函数重写对返回值要求有一个例外：协变，协变是子类虚函数与父类虚函数返回值类型不同，但子类和父类的返回值类型也必须是父子关系指针和引用。

子类虚函数没有写virtual，f依旧是虚函数，因为子类先继承了父类函数接口声明（接口部分是virtual A* f()  ），重写是重写父类虚函数的实现部分（ 重写函数实现部分是用子类虚函数的{ }里面的函数实现替代父类虚函数的{ }里面的函数实现 ）    

ps：我们自己写的时候子类虚函数也写上virtual
```cpp
class A{};
class B : public A {};
 
// 虚函数重写对返回值要求有一个例外：协变，父子关系指针和引用
// 
class Person {
public:
	virtual A* f() { 
		cout << "virtual A* Person::f()" << endl;
		return nullptr;
	}
};
 
class Student : public Person {
public:
	// 子类虚函数没有写virtual，f依旧时虚函数，因为先继承了父类函数接口声明
	// 重写父类虚函数实现
	// ps：我们自己写的时候子类虚函数也写上virtual
	// B& f() { 
	virtual B* f() {
		cout << "virtual B* Student::f()" << endl;
		return nullptr; 
	}
};
int main()
{
	Person p;
	Student s;
	Person* ptr = &p;
	ptr->f();
 
	ptr = &s;
	ptr->f();
 
	return 0;
}
```


##### 6.接口继承和实现继承
普通函数的继承是一种**实现继承**，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。**所以如果不实现多态，不要把函数定义成虚函数**。

所以就有了 子类虚函数没有写virtual，依旧是虚函数；子类虚函数使用的是父类虚函数的缺省参数，只是重写了实现。

**多态的坑题目（考接口继承）**
子类虚函数没有写virtual，func 依旧是虚函数，因为子类先继承了父类函数接口声明（接口部分是virtual A* f()  ），重写是重写父类虚函数的实现部分（ **重写函数实现部分是用子类虚函数的{ }里面的函数实现替代父类虚函数的{ }里面的函数实现** ）

ps：我们自己写的时候子类虚函数也写上virtual
```cpp
class A
{
public:
	virtual void func(int val = 1){ std::cout << "A->" << val << std::endl; }
	virtual void test(){ func(); }
};
 
class B : public A
{
public:
	void func(int val = 0){ std::cout << "B->" << val << std::endl; }
};
 
int main(int argc, char* argv[])
{
	B*p1 = new B;
	//p1->test();	这个是多态调用,下有讲解 二->6
	p1->func();	//普通调用
 
	A*p2 = new B;
	p2->func();	//多态调用
 
	return 0;
}
```
输出结果：
```
B->0
B->1
```
**题目讲解：多态调用**
![alt text](题目讲解（多态调用）.png)


p->test()，调用test中的this指针类型是A*，但指向的是对象B* p中的内容，类B中继承的test函数中又调用func函数，func函数没有写virtual 但依旧是虚函数，只要是虚函数重写就是接口继承，子类先继承了父类函数接口声明（父类接口部分是virtual void func(int va1=1) ），重写是重写父类虚函数的实现部分（ 即使用子类的函数的实现部分{}内容 ），所以缺省函数用的是父类的1，实现用的子类的函数实现，打印结果是 B->1


##### 7.析构函数的重写
析构函数名统一会被处理成destructor() 

**何时需要虚析构函数？**  
当你可能通过基类指针删除派生类对象时


只有派生类 Student 的析构函数重写了 Person 的析构函数，下面的 delete 对象调用析构函数，才能构成多态，才能保证 p1 和 p2 指向的对象正确的调用析构函数。  

函数名处理成`destructor()` 才能满足多态：  
如果父类的析构函数为虚函数，此时子类析构函数只要定义，无论是否加`virtual`关键字，都与父类的析构函数构成重写，虽然父类与子类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成`destructor`。

```cpp
class Person {
public:
    virtual ~Person() {cout << "~Person()" << endl;}
};

class Student : public Person {
public:
    virtual ~Student() { cout << "~Student()" << endl; }
};

int main()
{
    Person* p1 = new Person;
    Person* p2 = new Student;
    delete p1;
    delete p2;
    return 0; 
}
```

注意：期望delete ptr调用析构函数是一个多态调用， 如果设计一个类，**可能会作为基类，其次析构函数最好定义为虚函数**.

```cpp
class Person {
public:
	virtual ~Person()
	{
		cout << "~Person()" << endl;
	}
};
 
class Student : public Person {
public:
	// Person析构函数加了virtual,关系就变了
	// 重定义(隐藏)关系 -> 重写(覆盖)关系
	virtual ~Student()    //这里virtual加不加都行
	{
		cout << "~Student()" << endl;
		delete[] _name;
		cout << "delete:" << (void*)_name << endl;
	}
 
private:
	char* _name = new char[10]{ 'j','a','c','k' };
};
 
int main()
{
	// 对于普通对象是没有影响的
	//Person p;
	//Student s;
 
	// 期望delete ptr调用析构函数是一个多态调用
	// 如果设计一个类，可能会作为基类，其次析构函数最好定义为虚函数
	Person* ptr = new Person;
	delete ptr; // ptr->destructor() + operator delete(ptr)
 
	ptr = new Student;
	delete ptr;  // ptr->destructor() + operator delete(ptr)
 
	return 0;
}
```
输出结果：
```
~Person()
~Student()
delete:000002D0AB913C70
~Person()
```

##### 8.override 和 final
（1）final ：修饰虚函数，表示该虚函数不能再被重写；修饰类，该类不能被继承.  
（2）override：override写在子类中，要求严格检查是否完成重写，如果没有完成重写就报错.

override的作用时让编译器帮助用户检测是否派生类是否对基类总的某个虚函数进行重写，如 果重写成功，编译通过，否则，编译失败，因此 **override作用发生在编译时**。

override只能修饰子类的虚函数

override修饰子类成员函数虚函数时，编译时编译器会自动检测是否对基类中那个成员函数进行重写。（在子类里面是可以自己增加 成员函数的，如果这个成员函数不是虚函数，就不可以进行修饰）

 示例：如果父类没写virtual能检查出来并报错


##### 9.重载、覆盖(重写)、隐藏(重定义)的对比
（只有重写要求原型相同，原型相同就是指 函数名/参数/返回值都相同）
+ **函数重载**：在同一个作用域中，两个函数的函数名相同，参数个数，参数类型，参数顺序至少有一个不同，函数返回值的类型可以相同，也可以不相同。

+ **重定义（也叫做隐藏）**：是指在继承体系中，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) ，此时子类的函数会屏蔽掉父类的那个同名函数。

+ **重写（也叫做覆盖）**：是指在继承体系中子类定义了和父类函数名，函数参数，函数返回值完全相同的虚函数。此时构成多态，根据对象去调用对应的函数。

![alt text](重载覆盖隐藏对比.png)



##### 10.抽象类 
抽象类  -- 在现实一般没有具体对应实体,**不能实例化出对象**,间接功能：**要求子类需要重写，才能实例化出对象。** 

在虚函数的后面写上 =0 ，则这个函数为纯虚函数。包含纯虚函数的类叫做**抽象类**（也叫接口类），抽象类不能实例化出对象，但可以new别的对象来定义指针，例如Car* pBMW = new BMW;  

1. 子类继承后也不能实例化出对象，只有重写纯虚函数，子类才能实例化出对象。  
2. 父类的纯虚函数强制了派生类必须重写，才能实例化出对象（跟override异曲同工，override是放在子类虛函数，检查重写。功能有一些重叠和相似）另外纯虚函数更体现出了接口继承。  
3. 纯虚函数也可以写实现{ }，但没有意义，因为是接口继承，{ }中的实现会被重写；父类没有对象，所以无法调用纯虚函数。


作用:   
1. 抽象类**为抽象和设计的目的**而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。  
2. **对于暂时无法实现的函数，可以声明为纯虚函数**，留给派生类去实现。  

注意：
1. 抽象类只能作为基类来使用。
2. 不能声明抽象类的对象。
3. 构造函数不能是虚函数，析构函数可以是虚函数.

```cpp
class Car
{
public:
	virtual void Drive() = 0;
	//	// 实现没有价值，因为没有对象会调用他
	//	/*virtual void Drive() = 0
	//	{
	//		cout << " Drive()" << endl;
	//	}*/
};

class Benz :public Car
{
public:
	virtual void Drive()
	{
		cout << "Benz-舒适" << endl;
	}
};

class BMW :public Car
{
public:
	virtual void Drive()
	{
		cout << "BMW-操控" << endl;
	}
};

void Test()
{
	Car* pBenz = new Benz;
	pBenz->Drive();
	Car* pBMW = new BMW;
	pBMW->Drive();
}
```




#### （2）动态多态性的实现原理

##### 1.虚函数
动态多态性是通过`virtual`虚函数实现的,被`virtual`修饰的成员函数称为虚函数，虚函数的作用是用来实现多态，只有在需要实现多态时，才需要将成员函数设置成虚函数，否则没有必要。

1. 虚函数是动态绑定的基础。
2. 是非静态的成员函数。
3. 在类的声明中，在函数原型之前写virtual。
4. virtual 只用来说明类声明中的原型，不能用在函数实现时。
5. **具有继承性**，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。  
6. 本质：**不是重载声明而是覆盖**。
7. 调用方式：通过**基类指针或引用**，执行时会根据指针指向的对象的类，决定调用哪个函数。


**问题举例：**
```cpp
#include <iostream>
using namespace std;

class B0	//基类B0声明
{
public:	//外部接口
    virtual void display() //虚成员函数
    {cout<<"B0::display()"<<endl;} 
};

class B1: public B0	//公有派生
{ 
public:
    void display()  {  cout<<"B1::display()"<<endl;  }
};

class D1: public B1	//公有派生
{ 
public:
    void display() {  cout<<"D1::display()"<<endl;  }
};

void fun(B0 *ptr)	//普通函数
{ptr->display();}

int main()	//主函数
{	B0 b0,*p;	//声明基类对象和指针
    B1 b1;	//声明派生类对象
    D1 d1;	//声明派生类对象
    p=&b0;
    fun(p);	//调用基类B0函数成员
    p=&b1;
    fun(p);	//调用派生类B1函数成员
    p=&d1;
    fun(p);	//调用派生类D1函数成员
}
```
运行结果：
```
B0::display()
B1::display()
D1::display()
```
动态多态允许用一个或多个派生类对象的属性配置父类对象。在多态性的支持下，父类对象的某个接口会随着派生类对象的不同而执行不同的操作。

**构成动态多态的条件：(a) 调用函数的对象必须是指针或者引用；(b) 被调用的函数必须是虚函数。**


后期联编通过虚函数表V-Table实现动态多态，虚函数表是一个实例的虚函数地址表。若某个实例存在虚函数，则该实例的内存中会自动分配虚函数表，指明该实例实际应该调用的函数。实例中通过虚函数指针，指向虚函数表所在的内存位置。



未完待续




## 11.流类库与输入输出

目录
+ I/O流的概念及流类库结构
+ 输出流
+ 输入流
+ 输入/输出流
+ 小结

### 11.1I/O流的概念及流类库结构

**流对象与文件操作**
+ 程序建立一个**流对象**
  + 当程序与外界环境进行信息交换时，存在着两个对象，一个是程序中的对象，另一个是文件对象。
  + 流是一种抽象，它负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。
+ 指定这个流对象与某个文件对象建立连接
+ 程序操作流对象
+ 流对象通过文件系统对所连接的文件对象产生作用。


**提取与插入**
+ 读操作在流数据抽象中被称为（从流中）提取
+ 写操作被称为（向流中）插入。

**常用流类列表**
![alt text](image-1.png)


### 11.2输出流

**最重要的三个输出流**
+ ostream
+ ofstream
+ ostringstream

**预先定义的输出流对象**
+ cout 标准输出
+ cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。
+ clog 类似于cerr，但是有缓冲，缓冲区满时被输出。

**标准输出换向**
```cpp
ofstream fout("b.out");
streambuf*  pOld  =cout.rdbuf(fout.rdbuf());  
//…
cout.rdbuf(pOld); 
```

#### 11.2.1构造输出流对象
+ ofstream类支持磁盘文件输出
+ 如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的
```cpp
ofstream myFile("filename");
```
+ 可以在调用默认构造函数之后使用open成员函数打开文件
```cpp
ofstream myFile; //声明一个静态文件输出流对象
myFile.open("filename");   //打开文件，使流对象与文件建立联系
```
+ 在构造对象或用open打开文件时可以指定模式
```cpp
ofstream myFile("filename", ios_base::out | ios_base::binary);
```


#### 11.2.2使用插入运算符和操纵符

#### 11.2.3文件输出流函数

#### 11.2.4二进制输出文件

#### 11.2.5字符串输出流

### 11.3 输入流

#### 11.3.1构造输入流对象

#### 11.3.2使用提取运算符

#### 11.3.3输入流操作符

#### 11.3.4输入流相关函数

#### 11.3.5字符串输入流


### 11.4输入输出流












































